// Enums
var Character_SONIC = 0;
var Character_TAILS = 1;
var Character_KNUCKLES = 2;
var Character_MIGHTY = 3;
var Character_RAY = 4;

var ShieldType_NONE = 0;
var ShieldType_INSTA = -1;
var ShieldType_BASIC = 1;
var ShieldType_FIRE = 2;
var ShieldType_ELECTRIC = 3;
var ShieldType_BUBBLE = 4;

var CollideSide_TOP = 1;
var CollideSide_RIGHT = 2;
var CollideSide_BOTTOM = 4;
var CollideSide_LEFT = 8;

var Mode_MANIA = 3;
var Mode_ENCORE = 5;

class Player {
    // Create event
    event Create() {
        if (this.PropertyExists("filter") && !(this.PropertyGet("filter") & Mode_MANIA)) {
            this.Active = false;
            return;
        }

        // Setup
        if (this.PropertyExists("characterID")) {
            if (!(this.PropertyGet("characterID") & (1 << global.SelectedCharacter))) {
                this.Active = false;
                return;
            }
        }

        if (this.X < 0.0 ||
            this.Y < 0.0 ||
            this.X >= Scene.GetWidth() * 16.0 ||
            this.Y >= Scene.GetHeight() * 16.0) {
            this.Active = false;
            return;
        }

        this.AutoPhysics = false;

        this.SensorABCD_Ground_cos = [ 9, 0, -9, 0 ];
        this.SensorABCD_Ground_sin = [ 0, -9, 0, 9 ];
        this.SensorABCD_Air_cos = [ 7, 0, -7, 0 ];
        this.SensorABCD_Air_sin = [ 0, -7, 0, 7 ];
        this.SensorEF_cos = [ 10, 0, -10, 0 ];
        this.SensorEF_sin = [ 0, -10, 0, 10 ];
        this.simple_cos = [ 1, 0, -1, 0 ];
        this.simple_sin = [ 0, 1, 0, -1 ];
        this.simple_side = [ CollideSide_TOP, CollideSide_LEFT, CollideSide_BOTTOM, CollideSide_RIGHT ];

        this.Priority = DrawGroup_FGLow_High;

        this.InputUp            = false;
        this.InputDown          = false;
        this.InputLeft          = false;
        this.InputRight         = false;
        this.InputAction        = false;
        this.InputJump          = false;
        this.InputJumpPressed   = false;
        this.InputPause         = false;

        // if (GLOBAL_Checkpoint >= 0) {
        //     this.X = GLOBAL_CheckpointSpawnX;
        //     this.Y = GLOBAL_CheckpointSpawnY;
        // }
        // if (GLOBAL_SpecialWarpSpawnX >= 0) {
        //     this.X = GLOBAL_SpecialWarpSpawnX;
        //     this.Y = GLOBAL_SpecialWarpSpawnY;
        //     // Prevent further use as spawn point
        //     GLOBAL_SpecialWarpSpawnX = -1.0;
        //     GLOBAL_SpecialWarpSpawnY = -1.0;
        // }

        this.SuperForm = false;
        this.SuperFormLock = false;

        this.JumpHeights = [ 6.5, 6.5, 6.0, 6.5, 7.0 ];

        this.sensorsAngle = [ 0, 0, 0 ];
        this.sensorsLength = [ 0.0, 0.0, 0.0 ];
        this.sensorsCollided = [ 0, 0, 0 ];

        this.ShowingTailSprite = false;
        this.DashDustSprite = Resources.LoadSprite("Sprites/Global/Dust.bin", SCOPE_SCENE);
        this.DashDustTimer = 0;
        // 0: Skidding
        // 1: Spindash
        // 2: Dropdash
        // Create instance of tail sprite with it's own animation
        this.TailObject = Instance.Create("TailObject", this.X, this.Y);

        this.FlipRevolutionsRemaining = 0;
        this.DoSpriteRotation = false;
        this.BadnikHitChain = 0;

        ////////////
        this.Angle = 0;
        this.Rotation = 0.0;
        this.GroundSpeed = 0.0;
        this.UseGroundSpeed = true;
        this.Ground = true;
        this.Flip = false;
        // this.Priority
        this.Visible = true;
        this.PlaneIndex = 0;
        this.AngleMode = 0;
        this.Status = this.Player_StatusStanding;
        //
        this.LateUpdateGroundStatus = null;
        this.LateUpdateAirStatus = null;
        this.CameraPtr = null;
        // this.MainPlayerAnimation
        this.WalkThreshold = 4.0;
        this.RunThreshold = 6.0;
        this.DashThreshold = 12.0;
        this.Unk_0xA4 = false;
        this.TailRotation = 0.0;
        this.TailFlip = false;
        this.AnimationAfterSpring = 0;
        this.PlayerID = 0;
        this.DefaultH = 20.0;
        this.HitboxHalfW = 10.0;
        this.HitboxHalfH = this.DefaultH;
        this.Character = global.SelectedCharacter;
        this.Rings = 0;
        this.RingExtraLifeLevel = 100;
        this.Shield = ShieldType_NONE;
        this.Lives = 3;
        this.Score = 0;
        this.ScoreToNextLife = 50000;
        this.CombineRing = false;
        this.WaitTimer = 0;
        this.OuttaHereTimer = 0;
        this.SpindashRev = 0.0;
        this.Unk_0xEC = 0.0;
        this.RayGlideTurnValue = 0.25;
        this.UnderwaterAirTimer = 1800;
        this.Invincibility = false;
        this.SpeedShoesTimer = 1800;
        this.InvincibilityTimer = 0;
        this.CameraLockTimer = 0;
        this.SkidTimer = 0;
        this.PushingTimer = 0;
        this.Underwater = false;
        this.IsUpsideDown = false;
        this.UseChibiSprite = false;
        this.IsTransforming = false;
        this.SuperForm = 0;
        this.SuperForm_RingDrainTimer = 0;
        this.SuperForm_PulseValue = 0;
        this.SuperForm_PulseFlag = 0;
        this.CannotLoseRings = false;
        this.EnemyCombo = 0;
        this.RollHitboxDelta = 0.0;
        this.HorizontalCollisionFlag = 0;
        this.VerticalCollisionFlag = 0;
        this.TopSpeed         = 6.0;
        this.Acceleration     = 0.046875;
    	this.Friction         = 0.046875;
    	this.AirAcceleration  = 0.09375;
        this.Unk_0x158 = 0.0234375;
        this.Slope            = 0.125;
    	this.SlopeRollUp      = 0.078125;
    	this.SlopeRollDown    = 0.3125;
    	this.Deceleration     = 0.5;
        this.RollFriction     = 0.0234375;
        this.RollDeceleration = 0.125;
        this.GravityRate      = 0.21875;
        this.JumpHeight       = 6.8;
        this.JumpReleaseSpeed = -4.0;
        this.GroundSensorMask = 0;
        this.SensorRightX = 10.0;
        this.SensorRightShortX = 5.0;
        this.SensorMiddleX = 0.0;
        this.SensorLeftShortX = -5.0;
        this.SensorLeftX = -10.0;
        // this.HitboxHalfHCopy
        this.Unk_0x194 = 0;
        this.Unk_0x198 = 0;
        this.Unk_0x19C = 0;
        this.InputStatus = null;
        this.ControllerID = 1;
        this.InputLock = 0;
        //
        this.JumpAbility = 0;
        this.MidAirFlag = 0;
        this.JumpMovesetFunc = null;
        this.GroundedUpFunc = null;
        this.Unk_0x1D4 = 0;
        this.Unk_0x1D8 = 0;
        this.Unk_0x1DC = 0;
        this.Unk_0x1E0 = 0;
        this.Unk_0x1E4 = 0;
        this.KillFlag = false;
        this.Unk_0x1EC = 0;
        this.IsGhost = false;
        this.MaxGlideSpeed = 0;
        this.Unk_0x1F8 = 0;
        this.Unk_0x1FC = 0;
        this.Unk_0x200 = 0;
        this.Unk_0x204 = 0;
        this.Unk_0x208 = 0;
        this.Unk_0x20C = 0;
        this.Unk_0x210 = 0;
        this.RespawnDestinationX = 0.0;
        this.RespawnDestinationY = 0.0;
        this.Unk_0x21C = 0;
        this.Unk_0x220 = 0;
        this.Unk_0x224 = 0;
        this.Unk_0x228 = 0;
        this.Unk_0x22C = 0;
        this.Unk_0x230 = 0;
        this.Unk_0x234 = 0;

        this.HurtReboundTimer = 0;
        this.InvulnTimer = 0;
        this.InstashieldTimer = 0;

        this.TimerFrames = 0;
        this.StopTimer = false;

        this.DoubleJumpFlag = 0;
        this.KnucklesGlideFlag = 0;
        this.KnucklesGlideState = 0;
        this.KnucklesGlideAngle = 0;
        this.KnucklesGlideAngleDirection = 0;
        this.RayBoostCount = 0x100;
        this.RayGlideSpeedStore = 0;
        this.RayFacingUp = 0;

        this.ShieldObject = Instance.Create("ShieldObject", this.X, this.Y);
        this.ShieldObject.Player = this;
        // this.GiveShield(ShieldType_ELECTRIC, false);

        this.LevelWidth = Scene.GetWidth() * 16.0;
        this.LevelHeight = Scene.GetHeight() * 16.0;

        this.CameraShakeTimer = 0;
        this.CameraMinX = 0.0;
        this.CameraMinY = 0.0;
        this.CameraMaxX = this.LevelWidth - View.GetWidth(0);
        this.CameraMaxY = this.LevelHeight - View.GetHeight(0);

        this.RingSoundFlipFlag = false;

        this.LoadSounds();
        this.MoveCameraImmediately();
        this.LoadCharacterSprites();
        this.Player_ResetSpeeds();

        if (this.PropertyExists("Layer"))
            this.PlaneIndex = this.PropertyGet("Layer");


        if (Instance.GetCount("Zone") == 0) {
            Instance.Create("Zone", 0.0, 0.0);
        }

        // this.X = 3309.0;
        // this.Y = 1439.0;
        // this.CombineRing = true;
    }
    event LoadSounds() {
        this.SFX_Hurt = Resources.LoadSound("SoundFX/Global/Hurt.wav", SCOPE_GAME);
        this.SFX_Jump = Resources.LoadSound("SoundFX/Global/Jump.wav", SCOPE_GAME);
        this.SFX_Life = Resources.LoadSound("Music/1up.ogg", SCOPE_GAME); // Music/1up.ogg
        this.SFX_Roll = Resources.LoadSound("SoundFX/Global/Roll.wav", SCOPE_GAME);
        this.SFX_Skid = Resources.LoadSound("SoundFX/Global/Skidding.wav", SCOPE_GAME);
        this.SFX_Death = Resources.LoadSound("SoundFX/Global/Hurt.wav", SCOPE_GAME);
        this.SFX_Drown = Resources.LoadSound("SoundFX/Stage/Drown.wav", SCOPE_GAME);
        this.SFX_Spike = Resources.LoadSound("SoundFX/Global/Spike.wav", SCOPE_GAME);
        this.SFX_Flying = Resources.LoadSound("SoundFX/Global/Flying.wav", SCOPE_GAME);
        this.SFX_FlyingFall = Resources.LoadSound("SoundFX/Global/Tired.wav", SCOPE_GAME);
        this.SFX_GlideGrab = Resources.LoadSound("SoundFX/Global/Grab.wav", SCOPE_GAME);
        this.SFX_GlideLand = Resources.LoadSound("SoundFX/Global/Land.wav", SCOPE_GAME);
        this.SFX_GlideSlide = Resources.LoadSound("SoundFX/Global/Slide.wav", SCOPE_GAME);
        this.SFX_SpinCharge = Resources.LoadSound("SoundFX/Global/Charge.wav", SCOPE_GAME);
        this.SFX_SpinRelease = Resources.LoadSound("SoundFX/Global/Release.wav", SCOPE_GAME);
        this.SFX_PeelRelease = Resources.LoadSound("SoundFX/Global/PeelRelease.wav", SCOPE_GAME);

        this.SFX_ShieldAction_Fire = Resources.LoadSound("SoundFX/Global/FireDash.wav", SCOPE_GAME);
        this.SFX_ShieldAction_Electric = Resources.LoadSound("SoundFX/Global/LightningJump.wav", SCOPE_GAME);
        this.SFX_ShieldAction_Bubble = Resources.LoadSound("SoundFX/Global/BubbleBounce.wav", SCOPE_GAME);
        this.SFX_ShieldAction_Insta = Resources.LoadSound("SoundFX/Global/InstaShield.wav", SCOPE_GAME);

        this.SFX_ShieldObtain_Basic = Resources.LoadSound("SoundFX/Global/BlueShield.wav", SCOPE_GAME);
        this.SFX_ShieldObtain_Fire = Resources.LoadSound("SoundFX/Global/FireShield.wav", SCOPE_GAME);
        this.SFX_ShieldObtain_Electric = Resources.LoadSound("SoundFX/Global/LightningShield.wav", SCOPE_GAME);
        this.SFX_ShieldObtain_Bubble = Resources.LoadSound("SoundFX/Global/BubbleShield.wav", SCOPE_GAME);

        this.SFX_WaterWarning = Resources.LoadSound("SoundFX/Stage/Warning.wav", SCOPE_GAME);
        this.SFX_WaterSplash = Resources.LoadSound("SoundFX/Stage/Splash.wav", SCOPE_GAME);
        this.SFX_BubbleGet = Resources.LoadSound("SoundFX/Stage/Breathe.wav", SCOPE_GAME);

        this.SFX_Impact3 = Resources.LoadSound("SoundFX/Stage/Impact3.wav", SCOPE_GAME);

        this.SFX_BadnikDestroy = Resources.LoadSound("SoundFX/Global/Destroy.wav", SCOPE_GAME);
        this.SFX_BossHit = Resources.LoadSound("SoundFX/Stage/BossHit.wav", SCOPE_GAME);

        this.SFX_Spring = Resources.LoadSound("SoundFX/Global/Spring.wav", SCOPE_GAME);
        this.SFX_Checkpoint = Resources.LoadSound("SoundFX/Global/StarPost.wav", SCOPE_GAME);
        this.SFX_SpecialRing = Resources.LoadSound("SoundFX/Global/SpecialRing.wav", SCOPE_GAME);
        this.SFX_SpecialWarp = Resources.LoadSound("SoundFX/Global/SpecialWarp.wav", SCOPE_GAME);

        this.SFX_DropDash = Resources.LoadSound("SoundFX/Global/DropDash.wav", SCOPE_GAME);

        this.SFX_RayDive = Resources.LoadSound("SoundFX/Global/RayDive.wav", SCOPE_GAME);
        this.SFX_RaySwoop = Resources.LoadSound("SoundFX/Global/RaySwoop.wav", SCOPE_GAME);

        this.SFX_MightyUnspin = Resources.LoadSound("SoundFX/Global/MightyUnspin.wav", SCOPE_GAME);
        this.SFX_MightyDrill = Resources.LoadSound("SoundFX/Global/MightyDrill.wav", SCOPE_GAME);
        this.SFX_MightyLand = Resources.LoadSound("SoundFX/Global/MightyLand.wav", SCOPE_GAME);
        this.SFX_PimPom = Resources.LoadSound("SoundFX/Stage/PimPom.wav", SCOPE_GAME);

        this.SFX_RingLeft = Resources.LoadSound("SoundFX/Global/Ring.wav", SCOPE_GAME);
        this.SFX_RingRight = Resources.LoadSound("SoundFX/Global/Ring.wav", SCOPE_GAME);
        this.SFX_RingSpill = Resources.LoadSound("SoundFX/Global/LoseRings.wav", SCOPE_GAME);
        this.SFX_HyperRing = Resources.LoadSound("SoundFX/Global/HyperRing.wav", SCOPE_GAME);


        this.BGM_Drowning = Resources.LoadMusic("Music/Drowning.ogg", SCOPE_SCENE);
    }
    event StopAllSounds() {
        for (var i = this.SFX_Hurt; i <= this.SFX_RingSpill; i++) {
            Sound.Stop(i);
        }
    }
    event LoadCharacterSprites() {
        var lastDefaultH = this.DefaultH;

        switch (this.Character) {
            case 0: // Character_SONIC
                this.Sprite = Resources.LoadSprite("Sprites/Players/Sonic.bin", SCOPE_SCENE);
                if (this.SuperForm)
                    this.Sprite = Resources.LoadSprite("Sprites/Players/SuperSonic.bin", SCOPE_SCENE);

                this.DefaultH = 20.0;
                this.RollHitboxDelta = 5.0;
                this.JumpMovesetFunc = this.Player_MovesetSonic;
                break;
            case 1: // Character_TAILS
                this.Sprite = Resources.LoadSprite("Sprites/Players/Tails.bin", SCOPE_SCENE);

                this.DefaultH = 16.0;
                this.RollHitboxDelta = 0.0;
                this.JumpMovesetFunc = this.Player_MovesetTails;
                break;
            case 2: // Character_KNUCKLES
                this.Sprite = Resources.LoadSprite("Sprites/Players/Knux.bin", SCOPE_SCENE);

                this.DefaultH = 20.0;
                this.RollHitboxDelta = 5.0;
                this.JumpMovesetFunc = this.Player_MovesetKnuckles;
                break;
            case 3: // Character_MIGHTY
                this.Sprite = Resources.LoadSprite("Sprites/Players/Mighty.bin", SCOPE_SCENE);

                this.DefaultH = 20.0;
                this.RollHitboxDelta = 5.0;
                this.JumpMovesetFunc = this.Player_MovesetMighty;
                break;
            case 4: // Character_RAY
                this.Sprite = Resources.LoadSprite("Sprites/Players/Ray.bin", SCOPE_SCENE);

                this.DefaultH = 20.0;
                this.RollHitboxDelta = 5.0;
                this.JumpMovesetFunc = this.Player_MovesetRay;
                break;
        }

        this.Y -= this.DefaultH - lastDefaultH;
        this.HitboxHalfH = this.DefaultH;
    }

    // Update events
    event GetInput() {
        var input = Instance.GetNth("InputManager", 0);
        if (input) {
            this.InputUp = input.Up;
            this.InputDown = input.Down;
            this.InputLeft = input.Left;
            this.InputRight = input.Right;
            this.InputJump = input.Accept | input.Decline;
            this.InputJumpPressed = input.AcceptPressed | input.DeclinePressed;
        }

        if (Device.IsMobile()) {
            var vw = View.GetWidth(0);
            var vh = View.GetHeight(0);
            var vsw = vw / Window.GetWidth();
            var vsh = vh / Window.GetHeight();
            var tx, ty, tD, tP, dist, angl;
            var buttonY = vh - 64.0;
            for (var t = 0; t < 2; t++) {
                tx = Touch.GetX(t) * vsw;
                ty = Touch.GetY(t) * vsh;
                tD = Touch.IsDown(t);
                tP = Touch.IsPressed(t);

                dist = Math.Distance(64.0, buttonY, tx, ty);
                angl = Math.Direction(64.0, buttonY, tx, ty);
                if (dist < 64.0 && tD) {
                    angl = this.GetAngleMode(Number.AsInteger(this.RadiansToHex(angl)));
                    if (angl == 0x00)
                        this.InputRight = true;
                    else if (angl == 0x40)
                        this.InputUp = true;
                    else if (angl == 0x80)
                        this.InputLeft = true;
                    else if (angl == 0xC0)
                        this.InputDown = true;
                }

                dist = Math.Distance(vw - 64.0, buttonY, tx, ty);
                if (dist < 48.0) {
                    this.InputJump         |= tD;
                    this.InputJumpPressed  |= tP;
                }

                dist = Math.Distance(vw - 64.0, 24.0, tx, ty);
                if (dist < 48.0 && tP) {
                    var pauseMan = Instance.GetNth("PauseManager", 0);
                    if (pauseMan)
                        pauseMan.StartPause();
                }
            }
        }
    }

    event CreateSkidDust() {
        if (Scene_Frame % 5 == 0) {
            var dust = Instance.Create("DustPuff", this.X, this.Y + this.HitboxHalfH - 8.0);
            dust.Priority = this.Priority;
            dust.SetAnimation(0, 0);
        }
    }

    event ClearGlobals() {
        GLOBAL_Checkpoint = -1;
        GLOBAL_SpecialRings = 0;
        GLOBAL_CheckpointSpawnX = -1.0;
        GLOBAL_CheckpointSpawnY = -1.0;
        GLOBAL_SpecialWarpSpawnX = -1.0;
        GLOBAL_SpecialWarpSpawnY = -1.0;
    }
    event GiveShield(shield, doSound) {
        this.Shield = shield;

        if (this.Character == Character_SONIC) {
            this.InstashieldTimer = 0;
            this.DoubleJumpFlag = 0;
        }

        if (this.Shield == ShieldType_BASIC) {
            this.ShieldObject.SetAnimation(0, 0);
            if (doSound)
                Sound.Play(this.SFX_ShieldObtain_Basic);
        }
        else if (this.Shield == ShieldType_FIRE) {
            this.ShieldObject.SetAnimation(1, 0);
            if (doSound)
                Sound.Play(this.SFX_ShieldObtain_Fire);
        }
        else if (this.Shield == ShieldType_ELECTRIC) {
            this.ShieldObject.SetAnimation(3, 0);
            if (doSound)
                Sound.Play(this.SFX_ShieldObtain_Electric);
        }
        else if (this.Shield == ShieldType_BUBBLE) {
            this.ShieldObject.SetAnimation(5, 0);
            if (doSound)
                Sound.Play(this.SFX_ShieldObtain_Bubble);
        }
    }
    event GainRings(rings) {
        this.Rings += rings;
        if (this.Rings >= this.RingExtraLifeLevel) {
            this.GainLife();

            this.RingExtraLifeLevel += 100;
        }
    }
    event SpawnLostRings(rings, planeIndex) {
        var t = 0;
        var angle = 101.25 * Math_PI / 180.0;
        var n = false;
        var speed = 4.0;

        while (t < Math.Min(rings, 32)) {
            var ring = Instance.Create("Ring", this.X, this.Y);
            ring.RegatherTimer = 64;
            ring.DeathTimer = 256;
            ring.HSpeed =  Math.Cos(angle) * speed;
            ring.VSpeed = -Math.Sin(angle) * speed;
            ring.Bounceable = true;
            ring.Priority = this.Priority;
            ring.PlaneIndex = this.PlaneIndex;
            ring.Status = ring.Ring_StatusBounceable;
            if (n) {
                ring.HSpeed *= -1.0;
                angle += 22.5 * Math_PI / 180.0;
            }
            n = !n;
            t++;
            if (t == 16) {
                speed = 2.0;
                angle = 101.25 * Math_PI / 180.0;
            }
        }
    }
    event SpawnLostCombineRings(rings, planeIndex) {
        var ringsToSpawn = rings >> 2;
        if (ringsToSpawn > 8)
            ringsToSpawn = 8;
        else if (ringsToSpawn < 1)
            ringsToSpawn = 1;

        var ringIndex = 0;
        var startAngle = 0xC0 - 0x10 * (ringsToSpawn & 0xFFFFFFFE);
        var ringsWorth = rings / ringsToSpawn;

        if (ringsToSpawn & 1)
            startAngle = startAngle + 0x10;
        else
            startAngle = startAngle - 0x10;

        while (ringIndex < ringsToSpawn) {
            var ring = Instance.Create("Ring", this.X, this.Y);
            ring.HitboxW =
            ring.HitboxH = 32.0;
            ring.HitboxHalfW =
            ring.HitboxHalfH = 16.0;
            ring.RegatherTimer = 64;
            ring.DeathTimer = 256;
            ring.GravityRate = 0.0703125;
            ring.HSpeed = Static.HexCos(startAngle) * 3.0;
            ring.VSpeed = Static.HexSin(startAngle) * 3.0;
            ring.RingCount = ringsWorth;
            ring.Bounceable = true;
            ring.Priority = this.Priority;
            ring.PlaneIndex = this.PlaneIndex;
            ring.AngleSpeed = 0x180;
            ring.Angle = 0;
            ring.Status = ring.Ring_StatusBounceableCombine;
            ring.SetAnimation(1, 0);
            startAngle += 0x20;
            ringIndex++;
        }
    }
    event GetHurt(pain_x) {
        var doKnockback = false;
        var loseRings = false;

        if (this.CannotLoseRings) {
            doKnockback = true;
        }
        else {
            if (this.Shield != ShieldType_NONE) {
                this.Shield = ShieldType_NONE;
                doKnockback = true;
            }
            else if (this.Rings > 0) {
                doKnockback = true;
                loseRings = true;
            }
            else {
                this.KillFlag = 1;
                // 1: Normal death
                // 2: Soundless
                // 3: Drown death
                return;
            }
        }

        if (doKnockback) {
            this.Status = this.Player_StatusHurt;
            this.AnimationSpeedMult = 1.0;
            this.SetAnimation(18, 0);

            // Custom
            this.LateUpdateAirStatus = null;
            this.XSpeed = -2.0;
            if (this.X > pain_x)
                this.XSpeed = 2.0;

            this.YSpeed = -4.0;
            this.Ground = false;
            this.UseGroundSpeed = true;
            this.InvincibilityTimer = 120;
            if (this.Underwater) {
                this.XSpeed *= 0.5;
                this.YSpeed = -2.0;
            }
            if (loseRings)
                Sound.Play(this.SFX_RingSpill);
            else
                Sound.Play(this.SFX_Hurt);
        }
        if (loseRings) {
            if (this.CombineRing)
                this.SpawnLostCombineRings(this.Rings, this.PlaneIndex);
            else
                this.SpawnLostRings(this.Rings, this.PlaneIndex);
            this.CombineRing = false;
            this.Rings = 0;
            this.RingExtraLifeLevel = 100;
        }
    }
    event KillPlayer() {
        this.KillFlag = true;
        this.XSpeed = 0.0;
        if (!this.Underwater)
            this.YSpeed = -7.0;
        this.GroundSpeed = 0.0;
        this.Ground = false;
        this.InvulnTimer = 0;

        this.StopAllSounds();

        if (this.Underwater)
            Sound.Play(this.SFX_Drown);
        else
            Sound.Play(this.SFX_Death);
    }
    event GainLife() {
        this.Lives++;
        Sound.Play(this.SFX_Life);
    }
    event GainScore(count) {
        this.Score += count;
        if (this.Score >= this.ScoreToNextLife) {
            this.GainLife();
            this.ScoreToNextLife += 50000;
        }

        if (this.Score > 9999999)
            this.Score = 9999999;
    }
    event LoseLife() {
        this.Lives--;
    }
    event DoVictory() {
        if (!this.Victory) {
            this.Victory = true;

            this.GroundSpeed = 0.0;
            this.XSpeed = 0.0;
            this.YSpeed = 0.0;
        }
    }
    event IncreaseEnemyCombo() {
        var score = 10;
        switch (this.EnemyCombo) {
            case 0:
                score = 100;
                break;
            case 1:
                score = 200;
                break;
            case 2:
                score = 500;
                break;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
                score = 1000;
                break;
            case 15:
                score = 10000;
                break;
        }
        this.GainScore(score);
        if (this.EnemyCombo < 15)
            this.EnemyCombo++;
    }

    event CheckCanDamage(badnik) {
        var candamage = false;

        // When a character is curled, whether rolling, jumping, (or in Drop Dash)
        candamage |= (this.Curled) && (!this.HurtReboundTimer);
        // When a character is spindashed
        candamage |= this.Spindash;
        // Tails' tails
        candamage |= this.Character == Character_TAILS && this.DoubleJumpFlag != 0 && this.Y > badnik.Y;
        // Knuckles' knuckles
        candamage |= this.Character == Character_KNUCKLES && this.KnucklesGlideFlag && this.KnucklesGlideState == 1 && ((this.X < badnik.X && !this.Flip) || (this.X > badnik.X && this.Flip));
        // Mighty's...mighty shell
        candamage |= this.Character == Character_MIGHTY && this.DoubleJumpFlag == 1;

        if (badnik.Invulnerable)
            candamage = false;

        candamage |= this.SuperForm;
        return candamage;
    }
    event BadnikCollision(badnik) {
        if (this.KillFlag)
            return;

        if (this.CheckCanDamage(badnik)) {
            if (!badnik.IsDead) {
                badnik.Damaged();
                if (!(this.Character == Character_MIGHTY && this.DoubleJumpFlag == 1)) {
                    if (this.Y <= badnik.Y && this.YSpeed > 0.0) {
                        this.YSpeed = -this.YSpeed;
                    }
                    else {
                        this.YSpeed -= Math.Sign(this.YSpeed);
                    }
                }

                this.BadnikHitChain++;
                if (this.BadnikHitChain >= 16) {
                    this.BadnikHitChain  = 16;
                    this.GainScore(10000);
                }
                else if (this.BadnikHitChain >= 4)
                    this.GainScore(1000);
                else if (this.BadnikHitChain == 3)
                    this.GainScore(500);
                else if (this.BadnikHitChain == 2)
                    this.GainScore(200);
                else if (this.BadnikHitChain == 1)
                    this.GainScore(100);

                var animal = Instance.Create("Animal", badnik.X, badnik.Y);
                animal.Priority = badnik.Priority;
                animal.VSpeed = -4.0;
                animal.SetAnimation(0, 0);

                var bonus = Instance.Create("ScoreBonus", badnik.X, badnik.Y);
                bonus.SetAnimation(0, this.BadnikHitChain - 1);
            }
        }
        else {
            this.GetHurt(badnik.X);
        }
    }
    event BossCollision(badnik) {
        if (this.KillFlag)
            return;

        if (this.CheckCanDamage(badnik)) {
            if (!badnik.IsDead) {
                badnik.Damaged();
                Sound.Play(this.SFX_BossHit);

                if (this.KnucklesGlideState == 1)
                    this.KnucklesGlideState = 2;

                if (!(this.Character == Character_MIGHTY && this.DoubleJumpFlag == 1)) {
                    if (this.Ground) {
                        this.GroundSpeed = -this.GroundSpeed;
                    }
                    else {
                        this.XSpeed = -this.XSpeed;
                        this.YSpeed = -this.YSpeed;
                    }
                }
                else {
                    this.DoubleJumpFlag = 2;
                }
            }
        }
        else if (!badnik.Invulnerable) {
            this.GetHurt(badnik.X);
        }
    }

    // Camera movement function
    event MoveCamera() {
        // For looking up/down
        // if (this.Status )
        //     this.CameraLookTimer = Math.Max(-120, this.CameraLookTimer - 1);
        // else if (this.Crouching)
        //     this.CameraLookTimer = Math.Min(120, this.CameraLookTimer + 1);
        // else
        //     this.CameraLookTimer = 0;
        //
        // if (this.CameraLookTimer == -120)
        //     this.CameraLookOffset = Math.Max(-64.0, this.CameraLookOffset - 2.0);
        // else if (this.CameraLookTimer == 120)
        //     this.CameraLookOffset = Math.Min(88.0, this.CameraLookOffset + 2.0);
        // else
        //     this.CameraLookOffset -= Math.Sign(this.CameraLookOffset) * 2.0;

        // For a classic-styled slightly offset camera, use 0.0 for X and -16.0 for Y
        var cameraFocusOffsetX = 0.0;
        var cameraFocusOffsetY = -16.0;

        var cameraDestinationX = cameraFocusOffsetX + (this.X) - (View.GetWidth(0) / 2.0);
        var cameraDestinationY = cameraFocusOffsetY + (this.Y) - (View.GetHeight(0) / 2.0) + this.CameraLookOffset;


        // FIX: So the camera scrolls when Knuckles finishes ledge climb
        if (this.KnucklesGlideState == 5) {
            if (this.Flip)
                cameraDestinationX -= Ease.InQuad(this.KnucklesGlideAngle / 15.0) * 20.0;
            else
                cameraDestinationX += Ease.InQuad(this.KnucklesGlideAngle / 15.0) * 20.0;
        }

        // This prevents the camera from moving during a spindash or a flame shield action
        // NOTE: Spindash sets it to 16
        // if (this.C ameraLockTimer >  0) {
        //     this.C ameraLockTimer--;
        // }
        // else {
            // Horizontal camera movement
            var displaceX = cameraDestinationX - CameraX;
            var distanceX = Math.Abs(displaceX);
            var signX     = Math.Sign(displaceX);

            if (distanceX >= 8.0)
                CameraX += Math.Min(distanceX - 8.0, 16.0) * signX;

            // Vertical camera movement
            var displaceY = cameraDestinationY - CameraY;
            var distanceY = Math.Abs(displaceY);
            var signY     = Math.Sign(displaceY);

            // this.Ground
            if (this.VerticalCollisionFlag & 1) {
                var maxCameraYSpeed = 6.0;
                if (Math.Abs(this.GroundSpeed) >= 8.0)
                    maxCameraYSpeed = 16.0;

                // camera panning
                if (CameraY < this.CameraMinY) {
                    CameraY += 2.0;
                    if (CameraY > this.CameraMinY)
                        CameraY = this.CameraMinY;
                }
                else if (CameraY > this.CameraMaxY) {
                    CameraY -= 2.0;
                    if (CameraY < this.CameraMaxY)
                        CameraY = this.CameraMaxY;
                }
                else {
                    // Smooth
                    CameraY += Math.Min(distanceY / 4.0, maxCameraYSpeed) * signY;
                    // Rigid
                    // CameraY += Math.Min(distanceY, maxCameraYSpeed) * signY;
                }
            }
            else {
                if (distanceY > 32.0)
                    CameraY += Math.Min(distanceY - 32.0, 16.0) * signY;
            }
        // }

        if (CameraX < this.CameraMinX)
            CameraX = this.CameraMinX;
        if (CameraX > this.CameraMaxX)
            CameraX = this.CameraMaxX;
        if (CameraY < this.CameraMinY)
            CameraY = this.CameraMinY;
        if (CameraY > this.CameraMaxY)
            CameraY = this.CameraMaxY;

        if (this.CameraShakeTimer > 0) {
            var val = (this.CameraShakeTimer / 4) + 1;
            val *= ((this.CameraShakeTimer & 1) << 1) - 1;

            CameraY += val;

            this.CameraShakeTimer--;
        }

        // Make sure the camera doesn't try to move out of bounds
        CameraX = Math.Clamp(CameraX, 0.0, this.LevelWidth - View.GetWidth(0));
        CameraY = Math.Clamp(CameraY, 0.0, this.LevelHeight - View.GetHeight(0));
    }
    event MoveCameraImmediately() {
        var view_width = View.GetWidth(0);
        var view_height = View.GetHeight(0);

        // For a classic-styled slightly offset camera, use 0.0 for X and -16.0 for Y
        var cameraFocusOffsetX = 0.0;
        var cameraFocusOffsetY = -16.0;

        var cameraDestinationX = cameraFocusOffsetX + this.X - (view_width / 2.0);
        var cameraDestinationY = cameraFocusOffsetY + this.Y - (view_height / 2.0);

        if (cameraDestinationX < this.CameraMinX)
            cameraDestinationX = this.CameraMinX;
        if (cameraDestinationX > this.CameraMaxX)
            cameraDestinationX = this.CameraMaxX;
        if (cameraDestinationY < this.CameraMinY)
            cameraDestinationY = this.CameraMinY;
        if (cameraDestinationY > this.CameraMaxY)
            cameraDestinationY = this.CameraMaxY;

        CameraX = Math.Clamp(cameraDestinationX, 0, this.LevelWidth - view_width);
        CameraY = Math.Clamp(cameraDestinationY, 0, this.LevelHeight - view_height);
    }

    //// Player
    event Player_StatusNone() { }
    event Player_StatusStanding() {
        if (!this.Ground) {
            this.Status = this.Player_StatusJumping;
            this.Player_LateAirUpdate();
            return;
        }

        var gspeed = this.GroundSpeed;
        if (gspeed == 0.0) {
            if (this.InputLeft) {
                this.PushingTimer--;
            }
            else if (this.InputRight) {
                this.PushingTimer++;
            }
            else {
                this.PushingTimer = 0;
            }
        }
        else if (this.InputLeft || this.InputRight) {
            if (gspeed < 0)
                gspeed = -gspeed;
            if (gspeed > 1)
                this.PushingTimer = 0;
        }
        else {
            this.PushingTimer = 0;
        }

        // If we are standing on the floor in regular gravity,
        //    or on the ceiling in flipped gravity.
        var standingOnRelativeFloor = false;
        if (this.IsUpsideDown)
            standingOnRelativeFloor = this.AngleMode == 2;
        else
            standingOnRelativeFloor = this.AngleMode == 0;
        if (!standingOnRelativeFloor)
            this.PushingTimer = 0;

        this.Player_UpdateRotation();
        this.Player_HandleAcceleration();

        if (this.CameraPtr)
            this.CameraPtr.PlayerInAir = false;

        this.MidAirFlag = 0;
        this.LateUpdateAirStatus = this.Player_StatusJumping;
        if (this.SkidTimer <= 0) {
            var pushingTimer = this.PushingTimer;
            if (pushingTimer > -3 && pushingTimer < 3) {
                var absGroundSpeed = Math.Abs(this.GroundSpeed);
                var angle = this.Angle;
                // Moving
                if (absGroundSpeed != 0.0 || angle >= 0x20 && angle <= 0xE0 && !this.IsUpsideDown) {
                    this.WaitTimer = 0;
                    this.OuttaHereTimer = 0;
                    if (absGroundSpeed >= this.WalkThreshold) {
                        if (absGroundSpeed >= this.RunThreshold) {
                            var isCertainAnim = this.CurrentAnimation;
                            isCertainAnim = isCertainAnim < 8 || isCertainAnim > 9;

                            if (absGroundSpeed < this.DashThreshold) {
                                this.AnimationSpeedMult = Math.Min((absGroundSpeed * 16.0 + 96.0), 512.0) / 128.0;
                                this.SetAnimation(8, isCertainAnim);
                                this.RunThreshold = 5.5;
                                this.DashThreshold = 12.0;
                            }
                            else {
                                this.AnimationSpeedMult = 1.0;
                                this.SetAnimation(9, isCertainAnim);
                                this.DashThreshold = 11.5;
                            }
                        }
                        else {
                            if (this.CurrentAnimation != 5 || this.CurrentFrame == 3) {
                                this.AnimationSpeedMult = 1.0;
                                this.SetAnimation(7, 0);
                            }
                            this.AnimationSpeedMult = (absGroundSpeed * 12.0 + 64.0) / 96.0;
                            this.WalkThreshold = 3.5;
                            this.RunThreshold = 6.0;
                        }
                    }
                    else {
                        var anim = this.CurrentAnimation;
                        if (anim == 7) {
                            if (this.CurrentFrame == 9)
                                this.SetAnimation(5, 9);
                        }
                        else if (anim == 6) {
                            this.SetAnimation(5, this.CurrentFrame);
                        }
                        else {
                            this.SetAnimation(5, 0);
                        }
                        this.AnimationSpeedMult = (absGroundSpeed * 16.0 + 48.0) / 64.0;
                        this.WalkThreshold = 4.0;
                    }
                }
                // Standing
                else {
                    this.WalkThreshold = 4.0;
                    this.RunThreshold = 6.0;
                    this.DashThreshold = 12.0;

                    this.SensorRightX = 10.0;
                    this.SensorRightShortX = 5.0;
                    this.SensorMiddleX = 0.0;
                    this.SensorLeftShortX = -5.0;
                    this.SensorLeftX = -10.0;
                    this.SensorStartY = this.HitboxHalfH;

                    // this.GroundSensorMask = 0;
                    this.GroundSensorMask |= 0x01 * this.Entity_CanFindTile(-69, 0, this.PlaneIndex, this.SensorRightX, this.SensorStartY, 10);
                    this.GroundSensorMask |= 0x02 * this.Entity_CanFindTile(-69, 0, this.PlaneIndex, this.SensorRightShortX, this.SensorStartY, 10);
                    this.GroundSensorMask |= 0x04 * this.Entity_CanFindTile(-69, 0, this.PlaneIndex, this.SensorMiddleX, this.SensorStartY, 10);
                    this.GroundSensorMask |= 0x08 * this.Entity_CanFindTile(-69, 0, this.PlaneIndex, this.SensorLeftShortX, this.SensorStartY, 10);
                    this.GroundSensorMask |= 0x10 * this.Entity_CanFindTile(-69, 0, this.PlaneIndex, this.SensorLeftX, this.SensorStartY, 10);

                    var groundSensorMask = this.GroundSensorMask - 1;
                    if (groundSensorMask == 0x00 || groundSensorMask == 0x02) {
                        if (this.Flip ||
                            this.UseChibiSprite == 1 ||
                            this.Character == Character_SONIC && this.SuperForm == 2) {
                            this.Flip = true;
                            this.AnimationSpeedMult = 1.0;
                            this.SetAnimation(21, 0);
                        }
                        else {
                            this.AnimationSpeedMult = 1.0;
                            this.SetAnimation(22, 0);
                        }
                    }
                    else if (groundSensorMask == 0x0F || groundSensorMask == 0x17) {
                        if (!this.Flip ||
                            this.UseChibiSprite == 1 ||
                            this.Character == Character_SONIC && this.SuperForm == 2) {
                            this.Flip = false;
                            this.AnimationSpeedMult = 1.0;
                            this.SetAnimation(21, 0);
                        }
                        else {
                            this.AnimationSpeedMult = 1.0;
                            this.SetAnimation(22, 0);
                        }
                    }
                    else if (groundSensorMask == 0x6E || groundSensorMask == 0x73) {
                        this.AnimationSpeedMult = 1.0;
                        this.SetAnimation(21, 0);
                    }
                    else {
                        var v22;
                        // TODO: Make this simpler with an array in OnCreate
                        this.AnimationSpeedMult = 1.0;
                        if (this.Character == Character_SONIC) {
                            v22 = this.WaitTimer;
                            if (v22 != 720 || this.UseChibiSprite || this.SuperForm == 2) {
                                if (v22 < 240) {
                                    this.WaitTimer = v22 + 1;
                                    this.SetAnimation(0, 0);
                                }
                                else if (this.CurrentAnimation == 1) {
                                    this.WaitTimer = v22 + 1;
                                    if (this.CurrentFrame == 41)
                                        this.WaitTimer = 0;
                                }
                                else {
                                    this.WaitTimer = v22 + 1;
                                    this.SetAnimation(1, 0);
                                }
                            }
                            else {
                                if (this.CurrentAnimation == 2) {
                                    if (this.CurrentFrame == 67)
                                        this.WaitTimer = 0;
                                }
                                else
                                    this.SetAnimation(2, 0);
                            }
                        }
                        else if (this.Character == Character_TAILS) {
                            v22 = this.WaitTimer;
                            if (v22 < 240) {
                                this.WaitTimer = v22 + 1;
                                this.SetAnimation(0, 0);
                            }
                            else if (this.CurrentAnimation == 1) {
                                if (this.CurrentFrame == 45)
                                    this.WaitTimer = 0;
                            }
                            else
                                this.SetAnimation(1, 0);
                        }
                        else if (this.Character == Character_KNUCKLES) {
                            v22 = this.WaitTimer;
                            if (v22 < 240) {
                                this.WaitTimer = v22 + 1;
                                this.SetAnimation(0, 0);
                            }
                            else if (this.CurrentAnimation == 1) {
                                if (this.CurrentFrame == 69)
                                    this.WaitTimer = 0;
                            }
                            else
                                this.SetAnimation(1, 0);
                        }
                        else if (this.Character == Character_MIGHTY) {
                            v22 = this.WaitTimer;
                            if (v22 < 240) {
                                this.WaitTimer = v22 + 1;
                                this.SetAnimation(0, 0);
                            }
                            else if (this.CurrentAnimation == 1) {
                                if (this.CurrentFrame == 35)
                                    this.WaitTimer = 0;
                            }
                            else
                                this.SetAnimation(1, 0);
                        }
                        else if (this.Character == Character_RAY) {
                            v22 = this.WaitTimer;
                            if (v22 < 240) {
                                this.WaitTimer = v22 + 1;
                                this.SetAnimation(0, 0);
                            }
                            else if (this.CurrentAnimation == 1) {
                                if (this.CurrentFrame == 55)
                                    this.WaitTimer = 0;
                            }
                            else {
                                this.SetAnimation(1, 0);
                            }
                        }

                        // LABEL_92:
                        if (this.OuttaHereTimer++ >= 72000000) {
                            this.SetAnimation(27, 0);
                            // this.Status = sub_4CCE90;
                            this.UseGroundSpeed = false;
                            this.Unk0x44 = 0;
                            this.LateUpdateAirStatus = null;
                            this.LateUpdateGroundStatus = null;
                            this.XSpeed = 0.0;
                            this.YSpeed = 0.0;
                            // Sound.Play(this.SFX_OuttaHere);
                        }
                    }
                }
            }
            else {
                if (pushingTimer > 3)
                    this.PushingTimer = 3;
                if (pushingTimer < -3)
                    this.PushingTimer = -3;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(17, 0);
            }
        }
        else {
            var v5 = this.CurrentAnimation;

            // Custom
            this.CreateSkidDust();

            if (v5 == 13) {
                if ((this.Flip && this.GroundSpeed >= 0) ||
                    (!this.Flip && this.GroundSpeed <= 0)) {
                    // this.AnimationSpeedMult = 1.0;
                    this.SetAnimation(14, 0);
                }
                this.SkidTimer--;
            }
            else if (v5 == 14) {
                this.FrameCount = 4;
                if (this.CurrentFrame == this.FrameCount - 1) {
                    this.Flip = !this.Flip;
                    this.SkidTimer = 1;
                    this.AnimationSpeedMult = 1.0;
                    this.SetAnimation(5, 0);
                }
                this.SkidTimer--;
            }
            else {
                var v6 = Math.Abs(this.GroundSpeed);
                this.SetAnimation(13, 0);
                if (v6 >= 6.0) {
                    var v7 = 144.0;
                    if (v6 >= 10.0)
                        v7 = 64.0;
                    this.AnimationSpeedMult = v7 / 128.0;
                }
                else {
                    this.SkidTimer -= 8;
                }
                Sound.Play(this.SFX_Skid);
                this.SkidTimer--;
            }
        }

        // LABEL_120:
        if (this.InputJumpPressed) {
            this.Player_DoJump();
            this.WaitTimer = 0;
        }
        else {
            var absGroundSpeed = Math.Abs(this.GroundSpeed);
            if (absGroundSpeed != 0.0) {
                var rollThreshold = 0.53125;
                if (this.Status == this.Player_StatusLookingDown)
                    rollThreshold = 1.0625;

                if (absGroundSpeed >= rollThreshold && !this.InputLeft && !this.InputRight && this.InputDown) {
                    // TODO:
                    this.Player_DoRoll();
                    Sound.Play(this.SFX_Roll);
                }
            }
            else {
                var v28 = this.Angle;
                if ((v28 < 0x20 || v28 > 0xE0) && !this.AngleMode || this.IsUpsideDown && v28 == 0x80) {
                    if (this.InputUp) {
                        this.ResetAnimation(3, 1);
                        this.WaitTimer = 0;
                        this.Status = this.Player_StatusLookingUp;
                    }
                    else if (this.InputDown) {
                        this.ResetAnimation(4, 1);
                        this.WaitTimer = 0;
                        this.Status = this.Player_StatusLookingDown;
                    }
                }
            }
        }
    }
    event Player_StatusJumping() {
        // TODO:
        this.UseGroundSpeed = true;
        this.Player_HandleAirAcceleration();
        if (this.Ground) {
            this.Status = this.Player_StatusStanding;

            if (this.CameraPtr)
                this.CameraPtr.PlayerInAir = false;

            this.MidAirFlag = 0;
            return;
        }
        else {
            this.Player_LateAirUpdate();

            this.LateUpdateGroundStatus = this.Player_StatusStanding;
            if (this.YSpeed > 0) {
                var v4 = this.CurrentAnimation;
                if (v4 >= 11) {
                    if (v4 <= 12) {
                        this.AnimationSpeedMult = 1.0;
                        this.SetAnimation(this.AnimationAfterSpring, 0);
                    }
                    else if (v4 == 23 && this.CurrentFrame == 0) {
                        this.AnimationSpeedMult = 1.0;
                        this.SetAnimation(6, 0);
                    }
                }
            }

            if (this.CurrentAnimation == 0 ||
                this.CurrentAnimation == 5) {
                if (this.AnimationSpeedMult > 1.0)
                    this.AnimationSpeedMult = 1.0;

                this.SetAnimation(6, this.CurrentFrame);
            }
            else if (
                this.CurrentAnimation == 3 ||
                this.CurrentAnimation == 4 ||
                this.CurrentAnimation == 14) {
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(6, this.CurrentFrame);
            }
            else if (this.CurrentAnimation == 7) {
                this.SetAnimation(6, 0);
            }
            else if (this.CurrentAnimation == 10) {
                if (this.JumpMovesetFunc && this.YSpeed >= this.JumpReleaseSpeed) {
                    this.JumpMovesetFunc();
                }
            }
            else if (this.CurrentAnimation == 13) {
                if (this.SkidTimer == 0) {
                    this.AnimationSpeedMult = 1.0;
                    this.SetAnimation(6, this.CurrentFrame % 12);
                }
                else
                    this.SkidTimer--;
            }
            else if (this.CurrentAnimation == 15) {
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(10, 0);
            }
        }
    }
    event Player_StatusJumping_WithInputLock() {

    }
    event Player_StatusLookingDown() {
        var v0, v1, v2, v3, v4, v5, v6;

        if (this.IsUpsideDown)
            this.Rotation = Math_PI;

        this.InputLeft = false;
        this.InputRight = false;

        this.Player_HandleAcceleration();

        if (this.CameraPtr)
            this.CameraPtr.PlayerInAir = false;

        this.MidAirFlag = 0;
        this.LateUpdateAirStatus = this.Player_StatusJumping;
        if (this.InputDown) {
            this.AnimationSpeedMult = 1.0;
            this.SetAnimation(4, 1);
            if (this.CurrentFrame == 4)
                this.AnimationSpeedMult = 0.0;

            if (this.WaitTimer < 60) {
                this.WaitTimer++;
            }
            else {
                v5 = this.CameraPtr;
                if (v5) {
                    if (this.IsUpsideDown) {
                        if (v5.OffsetY > -96 )
                            v5.OffsetY -= 2;
                    }
                    else {
                        if (v5.OffsetY < 96)
                            v5.OffsetY += 2;
                    }
                }
            }
            if (this.InputJumpPressed) {
                this.ResetAnimation(15, 0);
                this.Status = this.Player_StatusSpinDash;
                this.SpindashRev = 0.0;
                this.SpindashPitch = 0;
                Sound.Play(this.SFX_SpinCharge);
            }
            return;
        }

        this.AnimationSpeedMult = 1.0;
        if (this.CurrentFrame == 0 || this.InputLeft || this.InputRight)
            this.Status = this.Player_StatusStanding;

        if (this.InputJumpPressed)
            this.Player_DoJump();
    }
    event Player_StatusLookingUp() {
        if (this.IsUpsideDown)
            this.Rotation = Math_PI;

        if (this.CameraPtr)
            this.CameraPtr.PlayerInAir = false;

        this.MidAirFlag = 0;
        this.LateUpdateAirStatus = this.Player_StatusJumping;
        if (this.InputUp) {
            this.SetAnimation(3, 1);
            this.InputLeft = false;
            this.InputRight = false;

            this.Player_HandleAcceleration();

            if (this.CurrentFrame == 5)
                this.AnimationSpeedMult = 0.0;

            if (this.WaitTimer < 60) {
                this.WaitTimer++;
            }
            else {
                var v6 = this.CameraPtr;
                if (v6) {
                    if (this.IsUpsideDown) {
                        if (v6.OffsetY < 96.0)
                            v6.OffsetY += 2.0;
                    }
                    else {
                        if (v6.OffsetY > -96.0)
                            v6.OffsetY -= 2.0;
                    }
                }
            }
            if (!this.InputJumpPressed)
                return;

            if (this.GroundedUpFunc)
                return this.GroundedUpFunc();

            return this.Player_DoJump();
        }

        this.Player_HandleAcceleration();

        this.AnimationSpeedMult = 1.0;

        if (this.CurrentFrame == 0 || this.InputLeft || this.InputRight)
            this.Status = this.Player_StatusStanding;

        if (this.InputJumpPressed)
            this.Player_DoJump();
    }
    event Player_StatusSpinDash() {
        // Custom
        this.DashDustTimer = (this.DashDustTimer + 1) % 14;

        this.AnimationSpeedMult = 1.0;
        if (this.InputJumpPressed) {
            this.SpindashRev += 2.0;
            if (this.SpindashRev > 9.0)
                this.SpindashRev = 9.0;

            if (this.SpindashPitch < 12)
                this.SpindashPitch++;

            this.ResetAnimation(15, 0);
            Sound.Play(this.SFX_SpinCharge);
        }
        else {
            this.SpindashRev -= this.SpindashRev / 32.0;
        }

        if (!this.InputDown) {
            this.AnimationSpeedMult = 1.0;
            this.SetAnimation(10, 0);
            if (this.CameraPtr) {
                this.CameraLockTimer = 15;
                this.CameraPtr.Status = this.CameraPtr.Camera_StatusNonFollow;
            }

            var baseSpeed = 8.0;
            if (this.SuperForm == 2)
                baseSpeed = 11.0;

            this.GroundSpeed = this.SpindashRev / 2.0 + baseSpeed;
            if (this.Flip)
                this.GroundSpeed = -this.GroundSpeed;

            Sound.Stop(this.SFX_SpinCharge);
            Sound.Play(this.SFX_SpinRelease);

            this.Player_DoRoll();
        }
    }
    event Player_StatusRoll() {
        this.Player_UpdateRotation();
        this.Player_HandleRollingAcceleration();

        this.JumpAbility = 0;
        if (!this.Ground) {
            this.Status = this.Player_StatusJumping;
            this.Player_LateAirUpdate();
            return;
        }

        if (this.Character == Character_TAILS)
            this.AnimationSpeedMult = 0.5;
        else
            this.AnimationSpeedMult = 4.0 / Math.Max(1.0, 5.0 - Math.Abs(this.GroundSpeed));

        if (this.CameraPtr)
            this.CameraPtr.PlayerInAir = false;

        this.MidAirFlag = 0;
        if (this.InputJumpPressed)
            this.Player_DoJump();
    }
    event Player_StatusRoll_WithInputLock() {

    }
    event Player_StatusHurt() {
        if (this.Ground) {
            this.Status = this.Player_StatusStanding;

            var xspeed = this.XSpeed;
            if (xspeed >= -2.0) {
                if (xspeed <= 2.0)
                    this.GroundSpeed = 0.0;
                else
                    this.GroundSpeed -= 2.0;
            }
            else {
                this.GroundSpeed += 2.0;
            }

            this.PushingTimer = 0;
            this.InputLock = 0;

            if (this.CameraPtr) {
                this.CameraPtr.PlayerInAir = false;
            }

            this.MidAirFlag = 0;
            this.SkidTimer = 0;
        }
        else {
            if (this.CameraPtr) {
                this.CameraPtr.PlayerInAir = true;
                this.CameraPtr.SetOnJump = 32.0;
            }

            this.SkidTimer = 0;
            if (!this.Underwater)
                this.YSpeed += 0.1875;
            else
                this.YSpeed += 0.05859375;
        }
    }
    event Player_StatusDead() {
        if (this.InvincibilityTimer) {
            this.InvincibilityTimer = 0;
            this.Visible = true;
        }

        this.YSpeed += this.GravityRate;
        this.XSpeed = 0.0;

        this.StopTimer = true;

        this.SetAnimation(19, 0);
        if (!this.CannotLoseRings) {
            var camera = this.CameraPtr;
            if (camera) {
                var maxY = camera.Y - camera.DestinationOffsetY + 384.0;
                if (this.Y > maxY)
                    this.Y = maxY;
                this.CameraLockTimer = 500;
            }
        }

        // if (this.YSpeed > 10.0)
        if (this.YSpeed > 0.0)
            Scene.Restart();
    }
    event Player_StatusGimmick() { }
    event Player_StatusGimmick2() { }
    event Player_StatusHangingFromTails() {
        var tails = null;
        if (tails && tails.Status != tails.Player_StatusTails_Flying)
            this.Status = this.Player_StatusJumping;
        if (this.Unk_0x1D8 != this.Unk_0x1E0)
            this.Status = this.Player_StatusJumping;

        if (this.Ground && this.YSpeed >= 0.0)
            this.Status = this.Player_StatusStanding;

        if (this.Status == this.Player_StatusHangingFromTails) {
            if (this.InputJumpPressed && this.InputDown) {
                var yspeed = -4.0;
                if (this.Underwater)
                    yspeed = -2.0;
                this.YSpeed = yspeed;
                this.Status = this.Player_StatusJumping;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(10, 0);
            }
        }
        else if (tails) {
            tails.Unk_0x1D4 = 30;
        }
    }
    event Player_StatusSpiningTube_PGZ() { }
    event Player_StatusFrozen_PGZ() { }
    event Player_StatusSliding_OOZ() { }
    event Player_StatusSwitchingToBG_MMZ() { }
    event Player_StatusSwitchingToFG_MMZ() { }
    event Player_StatusTurningSmall_MMZ() { }
    event Player_StatusTurningBig_MMZ() { }
    event Player_StatusFlyingIn() { }
    event Player_StatusJumpingIn() { }
    event Player_StatusSpringBasic() { }
    event Player_StatusScoreCard() { }
    event Player_StatusTransportTube_CPZ() { }
    event Player_StatusTransforming() { }
    // Sonic
    event Player_StatusSonic_DropDash() {
        var dashspeed;
        var maxspeed;
        if (this.Ground) {
            if (this.CameraPtr) {
                this.CameraPtr.PlayerInAir = false;
            }
            this.MidAirFlag = 0;

            if (this.InputRight)
                this.Flip = false;
            if (this.InputLeft)
                this.Flip = true;

            if (this.SuperForm) {
                dashspeed = 12.0;
                maxspeed = 13.0;
                this.CameraShakeTimer = 14;
            }
            else {
                dashspeed = 8.0;
                maxspeed = 12.0;
            }

            if (this.Flip) {
                if (this.XSpeed <= 0.0)
                    this.GroundSpeed = Math.Max(-maxspeed, -dashspeed + (this.GroundSpeed / 4.0));
                else if (this.Angle != 0x00)
                    this.GroundSpeed = -dashspeed + (this.GroundSpeed / 2.0);
                else
                    this.GroundSpeed = -dashspeed;
            }
            else {
                if (this.XSpeed >= 0.0)
                    this.GroundSpeed = Math.Min(maxspeed, dashspeed + (this.GroundSpeed / 4.0));
                else if (this.Angle != 0x00)
                    this.GroundSpeed = dashspeed + (this.GroundSpeed / 2.0);
                else
                    this.GroundSpeed = dashspeed;
            }

            // Set camera lag
            this.CameraLockTimer = 8;

            // Spawn dust
            var dust = Instance.Create("DustPuff", this.X, this.Y + this.HitboxHalfH + 1.0);
            dust.SetAnimation(2, 0);
            dust.Priority = this.Priority;
            dust.Flip = this.Flip;

            // Stop sounds
            Sound.Stop(this.SFX_DropDash);
            Sound.Stop(this.SFX_SpinCharge);
            if (this.SuperForm == 2)
                Sound.Play(this.SFX_PeelRelease);
            else
                Sound.Play(this.SFX_SpinRelease);

            this.AnimationSpeedMult = 1.0;
            this.SetAnimation(10, 0);
            if (this.AngleMode == 0)
                this.Y += this.RollHitboxDelta;
            this.PushingTimer = 0;
            this.Status = this.Player_StatusRoll;
            return;
        }

        if (this.InputJump) {
            this.Player_HandleAirAcceleration();
            this.Player_LateAirUpdate();

            this.AnimationSpeedMult = Math.Min(this.AnimationSpeedMult + 0.0625, 1.0);
        }
        else {
            this.MidAirFlag = 0;
            this.AnimationSpeedMult = 1.0;
            this.SetAnimation(10, 0);
            this.Status = this.Player_StatusJumping;
        }
    }
    event Player_StatusSonic_Peelout() { }
    // Tails
    event Player_StatusTails_Flying() {
        this.Player_HandleAirAcceleration();
        if (this.Ground) {
            this.Status = this.Player_StatusStanding;
            this.Player_LateAirUpdate();
            return;
        }

        var timeLen = 480;
        // var timeLen = 80;

        var v2 = this.YSpeed;
        if (v2 < -1.0)
            this.RayGlideSpeedStore = 0.03125;

        if (v2 < 1.0) {
            var val = this.RayGlideTurnValue;
            if (val >= 60)
                this.RayGlideSpeedStore = 0.03125;
            else
                this.RayGlideTurnValue = val + 1;
        }

        this.YSpeed += this.RayGlideSpeedStore;
        // if (!this.CannotLoseRings)

        if (this.WaitTimer >= timeLen) {
            if (!this.Underwater) {
                // if (this)
            }
            return;
        }

        if (this.Underwater) {
            this.SetAnimation(52, 0);
            this.AnimationSpeedMult = 2.0;
            if (this.YSpeed >= 0.0)
                this.AnimationSpeedMult = 1.0;
        }
        else {
            this.AnimationSpeedMult = 1.0;
            if (this.Status != this.Player_StatusHangingFromTails || this.YSpeed >= 0.0)
                this.SetAnimation(48, 0);
            else
                this.SetAnimation(52, 0);

            this.AnimationSpeedMult = 2.0;
            if (this.YSpeed >= 0.0)
                this.AnimationSpeedMult = 1.0;
        }

        this.WaitTimer++;
        if (this.WaitTimer == timeLen) {
            if (!this.Underwater) {
                // this.Underwater
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(49, 0);
            }
            else {
                this.AnimationSpeedMult = 1.0;
                if (this.Status == this.Player_StatusHangingFromTails)
                    this.SetAnimation(54, 0);
                else
                    this.SetAnimation(53, 0);
            }
        }

        if (this.InputJumpPressed && (!this.Underwater)) {
            if (this.InputDown) {
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(10, 0);
                this.Status = this.Player_StatusJumping;
                this.Player_LateAirUpdate();
                return;
            }
            this.RayGlideSpeedStore = -0.0625;
            this.RayGlideTurnValue = 0;
        }
    }
    event Player_StatusTails_Hanging() { }
    // Knuckles
    event Player_StatusKnuckles_GlidingLeft() {
        var left = true;
        var turnTimer, glideSpeedStore;
        if (!this.Ground) {
            if (this.InputJump) {
                turnTimer = this.WaitTimer;
                glideSpeedStore = this.RayGlideSpeedStore;
                if (left ? turnTimer != 0x100 : turnTimer != 0) {
                    if (glideSpeedStore < 4.0) {
                        this.RayGlideSpeedStore = glideSpeedStore + 0.0625;
                    }
                }
                else if (glideSpeedStore < 24.0) {
                    this.RayGlideSpeedStore = glideSpeedStore + 0.015625;
                }

                var yspeed = this.YSpeed;
                if (yspeed <= 0.5)
                    this.YSpeed = yspeed + 0.125;
                else
                    this.YSpeed = yspeed - 0.125;

                if (left ? turnTimer < 0x100 : turnTimer > 0)
                    this.WaitTimer = left ? turnTimer + 4 : turnTimer - 4;

                var check1Y, check2Y, v8, v10, v11;
                if (this.UseChibiSprite) {
                    check1Y = -1.0;
                    check2Y = 3.0;
                }
                else {
                    check1Y = -2.0;
                    check2Y = 11.0;
                }

                var postCheck1X = 0.0, postCheck2X = 0.0;
                if (left ? this.WaitTimer < 0x80 : this.WaitTimer >= 0x80) {
                    v8 = 0;
                    v10 = 0;
                }
                else {
                    var initialX = this.X;

                    if (left) {
                        this.X = initialX + this.XSpeed;
                        v8 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 3, this.PlaneIndex, -12.0, check1Y, true);
                        postCheck1X = this.X;

                        this.X = initialX + this.XSpeed;
                        v10 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 3, this.PlaneIndex, -12.0, check2Y, true);
                        postCheck2X = this.X;
                    }
                    else {
                        this.X = initialX + this.XSpeed;
                        v8 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 1, this.PlaneIndex, 12.0, check1Y, true);
                        postCheck1X = this.X;

                        this.X = initialX + this.XSpeed;
                        v10 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 1, this.PlaneIndex, 12.0, check2Y, true);
                        postCheck2X = this.X;
                    }

                    this.X = initialX;
                }

                var initXSpeed = this.XSpeed;
                var outXSpeed = this.RayGlideSpeedStore * Static.HexCos(this.WaitTimer >> 1);
                var v14 = initXSpeed;
                this.XSpeed = outXSpeed;

                if (!initXSpeed && outXSpeed) {
                    v14 = 0.0;
                    this.RayGlideSpeedStore = 4.0;
                    this.XSpeed = this.RayGlideSpeedStore * Static.HexCos(this.WaitTimer >> 1);
                }

                if (left ? this.InputRight : this.InputLeft) {
                    this.Status = left ? this.Player_StatusKnuckles_GlidingRight : this.Player_StatusKnuckles_GlidingLeft;
                    this.Flip = !left;
                    this.AnimationSpeedMult = 1.0;
                    this.ResetAnimation(this.CurrentAnimation, 0);
                }
                else if (v14 == 0.0 && this.WaitTimer == (left ? 0x100 : 0)) {
                    if (v8 || v10) {
                        this.WaitTimer = 0;
                        if (postCheck1X == postCheck2X) {
                            this.Status = this.Player_StatusKnuckles_Climbing;
                            this.GroundSpeed = 0.0;
                            this.XSpeed = 0.0;
                            this.YSpeed = 0.0;
                            Sound.Play(this.SFX_GlideGrab);
                        }
                        else {
                            // LABEL_32:
                            this.XSpeed *= 0.25;
                            this.RayGlideSpeedStore = 0.0;
                            this.AnimationSpeedMult = 1.0;
                            this.SetAnimation(49, 0);
                            this.Status = this.Player_StatusKnuckles_Falling;
                        }
                    }
                }
            }
            else {
                // LABEL_31:
                this.WaitTimer = 0;
                // LABEL_32:
                this.XSpeed *= 0.25;
                this.RayGlideSpeedStore = 0.0;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(49, 0);
                this.Status = this.Player_StatusKnuckles_Falling;
            }
        }
        else {
            if (this.AngleMode) {
                this.Status = this.Player_StatusStanding;

                var camera = this.CameraPtr;
                if (camera)
                    camera.PlayerInAir = false;

                this.MidAirFlag = 0;
                this.SkidTimer = 0;
            }
            else {
                this.WaitTimer = 0;
                this.Status = this.Player_StatusKnuckles_Sliding;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(51, 0);
                this.GroundSpeed = this.XSpeed;
                this.CreateSkidDust();
            }
        }

        // TODO:
        // LABEL_38:
        if (this.Y < 0.0 + 16.0) {
            this.XSpeed = 0.0;
            this.RayGlideSpeedStore = 0.0;
        }
    }
    event Player_StatusKnuckles_GlidingRight() {
        var left = false;
        var turnTimer, glideSpeedStore;
        if (!this.Ground) {
            if (this.InputJump) {
                turnTimer = this.WaitTimer;
                glideSpeedStore = this.RayGlideSpeedStore;
                if (left ? turnTimer != 0x100 : turnTimer != 0) {
                    if (glideSpeedStore < 4.0) {
                        this.RayGlideSpeedStore = glideSpeedStore + 0.0625;
                    }
                }
                else if (glideSpeedStore < 24.0) {
                    this.RayGlideSpeedStore = glideSpeedStore + 0.015625;
                }

                var yspeed = this.YSpeed;
                if (yspeed <= 0.5)
                    this.YSpeed = yspeed + 0.125;
                else
                    this.YSpeed = yspeed - 0.125;

                if (left ? turnTimer < 0x100 : turnTimer > 0)
                    this.WaitTimer = left ? turnTimer + 4 : turnTimer - 4;

                var check1Y, check2Y, v8, v10, v11;
                if (this.UseChibiSprite) {
                    check1Y = -1.0;
                    check2Y = 3.0;
                }
                else {
                    check1Y = -2.0;
                    check2Y = 11.0;
                }

                var postCheck1X = 0.0, postCheck2X = 0.0;
                if (left ? this.WaitTimer < 0x80 : this.WaitTimer >= 0x80) {
                    v8 = 0;
                    v10 = 0;
                }
                else {
                    var initialX = this.X;

                    if (left) {
                        this.X = initialX + this.XSpeed;
                        v8 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 3, this.PlaneIndex, -12.0, check1Y, true);
                        postCheck1X = this.X;

                        this.X = initialX + this.XSpeed;
                        v10 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 3, this.PlaneIndex, -12.0, check2Y, true);
                        postCheck2X = this.X;
                    }
                    else {
                        this.X = initialX + this.XSpeed;
                        v8 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 1, this.PlaneIndex, 12.0, check1Y, true);
                        postCheck1X = this.X;

                        this.X = initialX + this.XSpeed;
                        v10 = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 1, this.PlaneIndex, 12.0, check2Y, true);
                        postCheck2X = this.X;
                    }

                    this.X = initialX;
                }

                var initXSpeed = this.XSpeed;
                var outXSpeed = this.RayGlideSpeedStore * Static.HexCos(this.WaitTimer >> 1);
                var v14 = initXSpeed;
                this.XSpeed = outXSpeed;

                if (!initXSpeed && outXSpeed) {
                    v14 = 0.0;
                    this.RayGlideSpeedStore = 4.0;
                    this.XSpeed = this.RayGlideSpeedStore * Static.HexCos(this.WaitTimer >> 1);
                }

                if (left ? this.InputRight : this.InputLeft) {
                    this.Status = left ? this.Player_StatusKnuckles_GlidingRight : this.Player_StatusKnuckles_GlidingLeft;
                    this.Flip = !left;
                    this.AnimationSpeedMult = 1.0;
                    this.ResetAnimation(this.CurrentAnimation, 0);
                }
                else if (v14 == 0.0 && this.WaitTimer == (left ? 0x100 : 0)) {
                    if (v8 || v10) {
                        this.WaitTimer = 0;
                        if (postCheck1X == postCheck2X) {
                            this.Status = this.Player_StatusKnuckles_Climbing;
                            this.GroundSpeed = 0.0;
                            this.XSpeed = 0.0;
                            this.YSpeed = 0.0;
                            Sound.Play(this.SFX_GlideGrab);
                        }
                        else {
                            // LABEL_32:
                            this.XSpeed *= 0.25;
                            this.RayGlideSpeedStore = 0.0;
                            this.AnimationSpeedMult = 1.0;
                            this.SetAnimation(49, 0);
                            this.Status = this.Player_StatusKnuckles_Falling;
                        }
                    }
                }
            }
            else {
                // LABEL_31:
                this.WaitTimer = 0;
                // LABEL_32:
                this.XSpeed *= 0.25;
                this.RayGlideSpeedStore = 0.0;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(49, 0);
                this.Status = this.Player_StatusKnuckles_Falling;
            }
        }
        else {
            if (this.AngleMode) {
                this.Status = this.Player_StatusStanding;

                var camera = this.CameraPtr;
                if (camera)
                    camera.PlayerInAir = false;

                this.MidAirFlag = 0;
                this.SkidTimer = 0;
            }
            else {
                this.WaitTimer = 0;
                this.Status = this.Player_StatusKnuckles_Sliding;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(51, 0);
                this.GroundSpeed = this.XSpeed;
                this.CreateSkidDust();
            }
        }

        // TODO:
        // LABEL_38:
        if (this.Y < 0.0 + 16.0) {
            this.XSpeed = 0.0;
            this.RayGlideSpeedStore = 0.0;
        }
    }
    event Player_StatusKnuckles_Sliding() {
        if (!this.Ground) {
            this.WaitTimer = 0;
            this.AnimationSpeedMult = 1.0;
            this.SetAnimation(49, 0);
            this.Status = this.Player_StatusKnuckles_Falling;
            return;
        }

        var staticWorldInertia = 0.0;
        if (this.GroundSpeed && !staticWorldInertia) {
            if (!this.WaitTimer)
                Sound.Play(this.SFX_GlideSlide);

            this.WaitTimer = (this.WaitTimer + 1) & 7;
            if (this.CurrentFrame == 2)
                this.AnimationSpeedMult = 0.0;

            var gsp = this.GroundSpeed;
            if (Math.Abs(gsp) < 0.125 || !this.InputJump) {
                this.ResetAnimation(this.CurrentAnimation, 3);
                this.WaitTimer = 0;
                this.GroundSpeed = 0.0;
            }
            else if (this.InputJump) {
                if (gsp <= 0.0)
                    this.GroundSpeed = gsp + 0.125;
                else
                    this.GroundSpeed = gsp - 0.125;
            }
            return;
        }

        var camera = this.CameraPtr;
        if (camera)
            camera.PlayerInAir = false;

        this.MidAirFlag = 0;
        this.AnimationSpeedMult = 1.0;
        if (this.WaitTimer >= 16) {
            this.Status = this.Player_StatusStanding;
            this.SkidTimer = 0;
        }
        else {
            this.WaitTimer++;
        }
    }
    event Player_StatusKnuckles_Climbing() {
        if (this.Ground) {
            this.Status = this.Player_StatusStanding;

            var camera = this.CameraPtr;
            if (camera)
                camera.PlayerInAir = false;

            this.MidAirFlag = 0;
        }
        else {
            if (this.InputUp) {
                if (this.SuperForm == 2)
                    this.YSpeed = -2.0;
                else
                    this.YSpeed = -1.0;

                var cameraMinY = 0.0 + 20.0;
                if (this.Y < cameraMinY)
                    this.Y = cameraMinY;
            }
            else if (this.InputDown) {
                if (this.SuperForm == 2)
                    this.YSpeed = 2.0;
                else
                    this.YSpeed = 1.0;
            }
            else {
                this.YSpeed = 0.0;
            }

            if (this.InputJumpPressed) {
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(10, 0);

                this.Status = this.Player_StatusJumping;
                this.JumpAbility = 0;
                this.MidAirFlag = 1;
                Sound.Play(this.SFX_Jump);

                if (this.Flip) {
                    this.XSpeed = 4.0;
                    this.GroundSpeed = 4.0;
                    this.Flip = false;
                }
                else {
                    this.XSpeed = -4.0;
                    this.GroundSpeed = -4.0;
                    this.Flip = true;
                }

                this.YSpeed = -3.5;
                if (this.Underwater) {
                    this.XSpeed *= 0.5;
                    this.GroundSpeed *= 0.5;
                    this.YSpeed = -1.75;
                }
            }
            // TODO:
            else {
                this.AnimationSpeedMult = 1.0;

                this.GetHitboxFromSprite(this.Sprite, this.CurrentAnimation, this.CurrentFrame, 1);

                var checkTopY, checkWallY, offsetX, offsetY;
                if (this.UseChibiSprite) {
                    checkTopY = -4.0;
                    checkWallY = 4.0;
                    offsetY = -12.0;
                }
                else {
                    checkTopY = -10.0;
                    checkWallY = 11.0;
                    offsetY = -20.0;
                }

                var initialX = this.X;
                var checkTop = false, checkWall = false;
                var checkTopX = this.X;

                if (this.Flip) {
                    // Lfet
                    checkTop = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 3, this.PlaneIndex, -this.HitboxW / 2.0 - this.HitboxOffX - 1.0, checkTopY, true);
                    checkTopX = this.X;

                    this.X = initialX;
                    checkWall = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 3, this.PlaneIndex, -this.HitboxW / 2.0 - this.HitboxOffX - 1.0, checkWallY, true);

                    offsetX = -4.0;
                    if (this.YSpeed < 0.0 && this.X < checkTopX)
                        this.YSpeed = 0.0;
                }
                else {
                    // RIght
                    checkTop = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 1, this.PlaneIndex, this.HitboxW / 2.0 + this.HitboxOffX, checkTopY, true);
                    checkTopX = this.X;

                    this.X = initialX;
                    checkWall = Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 1, this.PlaneIndex, this.HitboxW / 2.0 + this.HitboxOffX, checkWallY, true);

                    offsetX = 4.0;
                    if (this.YSpeed < 0.0 && this.X > checkTopX)
                        this.YSpeed = 0.0;
                }

                this.Y += this.YSpeed;

                // if (Static.Entity_CheckTileCollision_Move(this, 0xFFFF, 2, this.PlaneIndex, offsetX, offsetY, true))
                //     this.YSpeed = 0.0;

                if (checkTop) {
                    if (checkWall) {
                        var yspeed = this.YSpeed;
                        if (yspeed < 0) {
                            this.SetAnimation(53, 0);
                        }
                        else if (yspeed > 0) {
                            this.SetAnimation(54, 0);
                        }
                        else {
                            this.SetAnimation(52, 0);
                        }

                        this.YSpeed = 0.0;
                    }
                    else {
                        this.SetAnimation(49, 0);
                        this.YSpeed = 0.0;
                        this.Status = this.Player_StatusKnuckles_Falling;
                    }
                }
                else {
                    this.Y = Math.Floor(this.Y);

                    if (this.UseChibiSprite)
                        this.Y -= 1.0;
                    else
                        this.Y += 2.0;

                    this.YSpeed = 0.0;
                    this.X = initialX;
                    this.Status = this.Player_StatusKnuckles_GettingUp;
                    this.WaitTimer = 1;
                    this.UseGroundSpeed = false;
                }
            }
        }
    }
    event Player_StatusKnuckles_GettingUp() {
        this.InputLeft = false;
        this.InputRight = false;
        this.SetAnimation(16, 1);

        this.AutoAnimate = false;
        this.Animate();

        var frame = this.CurrentFrame;
        if (this.WaitTimer != frame) {
            var v7 = frame == 6;
            if (frame < 6) {
                this.WaitTimer = frame;
                if (!this.UseChibiSprite) {
                    if (this.Flip)
                        this.X -= 5.0;
                    else
                        this.X += 5.0;
                    this.Y -= 8.0;
                }
                else {
                    if (this.Flip)
                        this.X -= 4.0;
                    else
                        this.X += 4.0;
                    this.Y -= 4.0;
                }
            }
        }
        if (frame == 6) {
            this.Ground = true;
            this.UseGroundSpeed = true;
        }
        if (frame == 9 - 1) {
            this.WaitTimer = 0;
            this.Status = this.Player_StatusStanding;
            this.AutoAnimate = true;
        }
    }
    event Player_StatusKnuckles_Falling() {
        if (this.Ground) {
            if (this.WaitTimer == 0) {
                Sound.Play(this.SFX_GlideLand);
            }

            var camera = this.CameraPtr;
            if (camera)
                camera.PlayerInAir = false;

            this.MidAirFlag = 0;

            var staticWorldInertia = 0.0;
            if (Math.Abs(staticWorldInertia) > 2.0) {
                if (staticWorldInertia <= 0.0) {
                    this.GroundSpeed = staticWorldInertia + 2.0;
                }
                else {
                    this.GroundSpeed = staticWorldInertia + 2.0;
                }
                this.XSpeed = this.GroundSpeed;
                this.WaitTimer = 16;
            }
            else {
                this.GroundSpeed = 0.0;
                this.XSpeed = 0.0;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(50, 0);
            }

            if (this.WaitTimer >= 16) {
                this.Status = this.Player_StatusStanding;
                this.SkidTimer = 0;
                this.WaitTimer = 0;
            }
            else {
                this.WaitTimer++;
            }
        }
        else {
            this.Player_HandleAirAcceleration();
            this.Player_LateAirUpdate();
        }
    }
    // Mighty
    event Player_StatusMighty_HammerDrop() { }
    event Player_StatusMighty_UnspinInvincible() {
        this.Player_HandleAirAcceleration();
        if (this.Ground) {
            this.Status = this.Player_StatusStanding;
            if (this.CameraPtr) {
                this.CameraPtr.PlayerInAir = false;
            }
            this.MidAirFlag = 0;
        }
        else {
            this.InvincibilityTimer++;
            if (this.CameraPtr) {
                this.CameraPtr.PlayerInAir = true;
                this.CameraPtr.SetOnJump = 32.0;
            }

            this.Player_LateAirUpdate();
            // TODO: do this here
        }
    }
    // Ray
    event Player_StatusRay_Flying() { }
    // ERSS
    event Player_StatusEggReverieSuperForm() {
        if (this.Character == Character_KNUCKLES)
            this.SetAnimation(48, 6);
        else
            this.SetAnimation(8, 0);
        this.Ground = false;

        // Vertical movement
        if (this.InputUp) {
            var yspeed = this.YSpeed;
            if (yspeed > -this.TopSpeed) {
                yspeed = yspeed - this.Acceleration;
                if (yspeed > 0.0)
                    yspeed = yspeed - this.Acceleration;
                this.YSpeed = yspeed;
            }
        }
        else if (this.InputDown) {
            var yspeed = this.YSpeed;
            if (yspeed < this.TopSpeed) {
                yspeed = yspeed + this.Acceleration;
                if (yspeed < 0.0)
                    yspeed = yspeed + this.Acceleration;
                this.YSpeed = yspeed;
            }
        }
        else {
            var absYspeed = Math.Abs(this.YSpeed);
            var signYspeed = Math.Sign(this.YSpeed);
            if (absYspeed < this.Friction) {
                this.YSpeed = 0.0;
            }
            else {
                this.YSpeed -= signYspeed * this.Friction;
            }
        }

        // Horizontal movement
        if (this.InputLeft) {
            var xspeed = this.XSpeed;
            if (xspeed > -this.TopSpeed) {
                xspeed = xspeed - this.Acceleration;
                if (xspeed > 0.0)
                    xspeed = xspeed - this.Acceleration;
                this.XSpeed = xspeed;
            }
        }
        else if (this.InputRight) {
            var xspeed = this.XSpeed;
            if (xspeed < this.TopSpeed) {
                xspeed = xspeed + this.Acceleration;
                if (xspeed < 0.0)
                    xspeed = xspeed + this.Acceleration;
                this.XSpeed = xspeed;
            }
        }
        else {
            var absYspeed = Math.Abs(this.YSpeed);
            var signYspeed = Math.Sign(this.YSpeed);
            if (absYspeed < this.Friction) {
                this.YSpeed = 0.0;
            }
            else {
                this.YSpeed -= signYspeed * this.Friction;
            }
        }
    }
    // Move Sets
    event Player_MovesetSonic() {
        if (this.MidAirFlag == 1) {
            if (this.InputJumpPressed) {
                if (this.Invincibility) {
                    this.MidAirFlag++;
                }
                else {
                    var shield = this.Shield;
                    if (shield == ShieldType_NONE) {
                        this.Invincibility = -8;
                        this.MidAirFlag = 0;
                        Sound.Play(this.SFX_ShieldAction_Insta);

                        this.MidAirFlag++;
                        this.MidAirFlag++;
                    }
                    else if (shield == ShieldType_BASIC) {
                        this.MidAirFlag++;
                    }
                    else if (shield == ShieldType_BUBBLE) {
                        this.XSpeed *= 0.5;
                        this.YSpeed = 8.0;
                        // this.Status =



                        Sound.Play(this.SFX_ShieldAction_Bubble);
                    }
                    else if (shield == ShieldType_FIRE) {
                        this.MidAirFlag = 0;
                        this.YSpeed = 0.0;
                        this.XSpeed = this.Flip ? -8.0 : 8.0;

                        this.CameraLockTimer = 15;

                        Sound.Play(this.SFX_ShieldAction_Fire);
                    }
                    else if (shield == ShieldType_ELECTRIC) {
                        this.MidAirFlag = 0;
                        this.YSpeed = -5.5;

                        Sound.Play(this.SFX_ShieldAction_Electric);
                    }
                }
            }
            return;
        }
        if (this.MidAirFlag >= 1 && this.InputJump) {
            this.MidAirFlag++;
            if (this.MidAirFlag > 21) {
                this.Status = this.Player_StatusSonic_DropDash;
                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(16, 0);
                Sound.Play(this.SFX_DropDash);
            }
        }
    }
    event Player_MovesetTails() {
        if (this.InputJumpPressed && this.MidAirFlag == 1) {
            // if (!this.IsUpsideDown) {
                this.MidAirFlag = 0;
                this.WaitTimer = 0;
                this.RayGlideSpeedStore = 0.03125;
                this.AnimationSpeedMult = 1.0;
                if (!this.Underwater)
                    this.SetAnimation(48, 0);
                else
                    this.SetAnimation(52, 0);
                this.Status = this.Player_StatusTails_Flying;
                this.LateUpdateGroundStatus = null;
                this.LateUpdateAirStatus = null;
            // }
        }
    }
    event Player_MovesetKnuckles() {
        if (this.InputJumpPressed && this.MidAirFlag == 1) {
            // if (!this.IsUpsideDown) {
                this.MidAirFlag = 0;
                this.WaitTimer = 0;
                this.RayGlideSpeedStore = 4.0;
                if (this.YSpeed < 0.0)
                    this.YSpeed = 0.0;

                if (this.Flip) {
                    this.Status = this.Player_StatusKnuckles_GlidingLeft;
                    this.XSpeed = -4.0;
                    this.WaitTimer = 0x100;
                }
                else {
                    this.Status = this.Player_StatusKnuckles_GlidingRight;
                    this.XSpeed = 4.0;
                    this.WaitTimer = 0x0;
                }

                this.LateUpdateGroundStatus = null;
                this.LateUpdateAirStatus = null;
                this.SetAnimation(48, 6);
            // }
        }
    }
    event Player_MovesetMighty() { }
    event Player_MovesetRay() { }
    event Player_MovesetERSS() { }

    // Handling
    event Player_HandleFallOff() {
        if (this.AngleMode != 0) {
            if (this.Angle >= 0x40 && this.Angle <= 0xC0) {
                if (this.GroundSpeed > -2.0 && this.GroundSpeed < 2.0) {
                    this.XSpeed = this.GroundSpeed * Static.HexCos(this.Angle);
                    this.YSpeed = this.GroundSpeed * Static.HexSin(this.Angle);
                    this.Ground = false;
                    this.Angle = 0;
                    this.AngleMode = 0;
                }
            }
        }
    }
    event Player_HandleAcceleration() {
        var inputLockTimer,
            inputLeft,
            inputRight;

        inputLockTimer = this.InputLock;
        if (inputLockTimer > 0) {
            this.InputLock = inputLockTimer - 1;
            if (this.IsUpsideDown)
                return;

            this.GroundSpeed += Static.HexSin(this.Angle) * 0.125;
            return this.Player_HandleFallOff(); // goto LABEL_69;
        }
        else {
            if (this.IsUpsideDown) {
                inputLeft = this.InputRight;
                inputRight = this.InputLeft;
            }
            else {
                inputLeft = this.InputLeft;
                inputRight = this.InputRight;
            }

            if (inputLeft) {
                if (this.GroundSpeed > -this.TopSpeed) {
                    // Going left
                    if (this.GroundSpeed <= 0.0) {
                        this.GroundSpeed -= this.Acceleration;
                    }
                    // Going right
                    else {
                        if (!this.AngleMode && this.GroundSpeed > 4.0) { // && !Zone_Info->dword154
                            this.Flip = false;
                            this.SkidTimer = 24;
                        }

                        if (this.GroundSpeed < this.Deceleration)
                            this.GroundSpeed = -this.Deceleration;
                        else
                            this.GroundSpeed -= this.Deceleration;
                    }
                }
                if (this.GroundSpeed <= 0.0 && this.SkidTimer < 1)
                    this.Flip = true;
            }
            if (inputRight) {
                if (this.GroundSpeed < this.TopSpeed) {
                    // Going right
                    if (this.GroundSpeed >= 0.0) {
                        this.GroundSpeed += this.Acceleration;
                    }
                    // Going left
                    else {
                        if (!this.AngleMode && this.GroundSpeed < -4.0) { // && !Zone_Info->dword154
                            this.Flip = true;
                            this.SkidTimer = 24;
                        }

                        if (this.GroundSpeed > -this.Deceleration)
                            this.GroundSpeed = this.Deceleration;
                        else
                            this.GroundSpeed += this.Deceleration;
                    }
                }
                if (this.GroundSpeed >= 0.0 && this.SkidTimer < 1)
                    this.Flip = false;
            }

            if (this.InputLeft || this.InputRight) {
                if (this.IsUpsideDown)
                    return;

                // Slope
                this.GroundSpeed += Static.HexSin(this.Angle) * 0.125;

                if (this.InputRight) {
                    if (!this.InputLeft) {
                        if (this.Angle > 0xC0 && this.Angle < 0xE4 &&
                            this.GroundSpeed > -2.0 && this.GroundSpeed < 2.5) {
                            this.InputLock = 30;
                        }
                    }
                }
                else {
                    if (this.InputLeft) {
                        if (this.Angle > 0x1C && this.Angle < 0x40 &&
                            this.GroundSpeed < 2.0 && this.GroundSpeed > -2.5) {
                            this.InputLock = 30;
                        }
                    }
                }

                // LABEL_69:
                return this.Player_HandleFallOff();
            }

            var spd;
            if (this.GroundSpeed <= 0.0) {
                spd = this.GroundSpeed + this.Friction;
                if (spd > 0.0)
                    spd = 0.0;
                this.GroundSpeed = spd;
            }
            else {
                spd = this.GroundSpeed - this.Friction;
                if (spd < 0.0)
                    spd = 0.0;
                this.GroundSpeed = spd;
            }

            if (!this.IsUpsideDown) {
                if (this.GroundSpeed > 0.125 || this.GroundSpeed < -0.125)
                    this.GroundSpeed += Static.HexSin(this.Angle) * 0.125;

                if ((this.Angle <= 0xC0 || this.Angle >= 0xE4) && (this.Angle <= 0x1C || this.Angle >= 0x40))
                    return this.Player_HandleFallOff();

                if (this.GroundSpeed > -1.0 && this.GroundSpeed < 1.0)
                    this.InputLock = 30;
                else
                    return this.Player_HandleFallOff();
            }
        }
    }
    event Player_HandleRollingAcceleration() {
        // var canMoveLeftRight = this.InputLock == 0;

        var rollDeceleration = this.RollDeceleration;
        var rollFriction = this.RollFriction;

        // Rolling ground deceleration
        if (this.InputLeft) {
            if (this.GroundSpeed > 0.0)
                this.GroundSpeed -= rollDeceleration;
        }
        else if (this.InputRight) {
            if (this.GroundSpeed < 0.0)
                this.GroundSpeed += rollDeceleration;
        }

        // Rolling friction
        if (Math.Abs(this.GroundSpeed) < rollFriction)
            this.GroundSpeed = 0.0;
        else
            this.GroundSpeed -= Math.Sign(this.GroundSpeed) * rollFriction;

        // Rolling slope acceleration
        var sin = -Static.HexSin(this.Angle);
        if (Math.Sign(this.GroundSpeed) == Math.Sign(sin))
            sin = (this.SlopeRollUp * sin);
        else
            sin = (this.SlopeRollDown * sin);

        if (Math.Abs(this.GroundSpeed) < Math.Abs(sin))
            this.GroundSpeed = 0.0;
        else
            this.GroundSpeed -= sin;

        // Hard Roll Speed Cap in Mania
        this.GroundSpeed = Math.Clamp(this.GroundSpeed, -18.0, 18.0);

        // Handle stopping and fall off
        if (this.AngleMode == 0) {
            if (this.Status == this.Player_StatusRoll_WithInputLock) {
                if (Math.Abs(this.GroundSpeed) < 1.0)
                    this.GroundSpeed = this.Flip ? -4.0 : 4.0;
            }
            else {
                if (Math.Abs(this.GroundSpeed) < rollFriction) {
                    this.Status = this.Player_StatusStanding;
                    this.GroundSpeed = 0.0;
                }
            }
        }
        else if (this.AngleMode == 2) {
            if (this.IsUpsideDown) {
                if (Math.Abs(this.GroundSpeed) < rollFriction) {
                    this.Status = this.Player_StatusStanding;
                    this.GroundSpeed = 0.0;
                }
            }
            else {
                this.Player_HandleFallOff();
            }
        }
        else {
            this.Player_HandleFallOff();
        }


    }
    event Player_HandleAirAcceleration() {
        if (this.YSpeed < 0.0 && this.YSpeed > -4.0) {
            this.XSpeed -= this.XSpeed / 32.0;
        }

        // Air acceleration
        if (this.InputLeft) {
            if (this.XSpeed > -this.TopSpeed)
                this.XSpeed -= this.AirAcceleration;
            this.Flip = true;
        }
        else if (this.InputRight) {
            if (this.XSpeed < this.TopSpeed)
                this.XSpeed += this.AirAcceleration;
            this.Flip = false;
        }
    }

    event Player_DoJump() {
        var v2, v3;
        var jumpHeight = this.JumpHeight;
        if (this.Underwater)
            jumpHeight -= 3.0;

        v2 = this.GravityRate + jumpHeight;
        this.InputLock = 0;
        this.Ground = false;
        // TODO:
        if (this.AngleMode == 0 && this.Status != this.Player_StatusRoll)
            this.Y += this.RollHitboxDelta;

        this.XSpeed = this.GroundSpeed * Static.HexCos(this.Angle);
        this.YSpeed = this.GroundSpeed * Static.HexSin(this.Angle);
        this.XSpeed -= jumpHeight * -Static.HexSin(this.Angle);
        this.YSpeed -= jumpHeight * Static.HexCos(this.Angle);

        // TODO:
        var camera;
        if (camera = this.CameraPtr) {
            camera.PlayerInAir = true;
            camera.SetOnJump = 32.0;
        }
        this.SetAnimation(10, 0);
        if (this.Character == Character_TAILS) {
            this.AnimationSpeedMult = 0.5;
        }
        else {
            this.AnimationSpeedMult = 4.0 / Math.Max(1.0, 5.0 - Math.Abs(this.GroundSpeed));
        }

        this.Angle = 0;
        this.AngleMode = 0;
        this.SkidTimer = 0;
        this.JumpAbility = 1;
        this.MidAirFlag = 1;
        this.Status = this.Player_StatusJumping;

        Sound.Play(this.SFX_Jump);
    }
    event Player_DoRoll() {
        this.AnimationSpeedMult = 1.0;
        this.SetAnimation(10, 0);

        this.PushingTimer = 0;
        this.Status = this.Player_StatusRoll;
        if (this.AngleMode == 0) {
            this.Y += this.RollHitboxDelta;
        }
    }
    event Player_DoMightyUnspin(speed, makeInvinc, entity, value) {
        if (this.Character != Character_MIGHTY)
            return false;

        var playerStatus = this.Status;
        if (playerStatus == this.Player_StatusHurt ||
            playerStatus == this.Player_StatusDead ||
            // playerStatus == this.Player_ ||
            playerStatus == this.Invincibility ||
            playerStatus == this.InvincibilityTimer > 0)
            return false;

        var anim = this.CurrentAnimation;
        if (anim == 10 || anim == 15 || anim == 16) {
            var angle = Math.Atan(this.X - entity.X, this.Y - entity.Y);
            var xspeed = speed * Math.Cos(angle);
            var yspeed = speed * Math.Sin(angle);

            if (anim != 48) {
                this.XSpeed = xspeed;
                this.GroundSpeed = xspeed;
            }
            this.YSpeed = yspeed;

            if (makeInvinc) {
                if (this.Status == this.Player_StatusMighty_HammerDrop) {
                    this.Status = this.Player_StatusJumping;
                    this.AnimationSpeedMult = 1.0;
                    this.SetAnimation(10, 0);
                }

                if (this.CurrentAnimation == 15) {
                    this.AnimationSpeedMult = 1.0;
                    this.SetAnimation(10, 0);
                    if (this.Status == this.Player_StatusSpinDash) {
                        if (this.Ground)
                            this.Status = this.Player_StatusRoll;
                        else
                            this.Status = this.Player_StatusJumping;
                    }
                }
            }
            else {
                this.YSpeed = -4.5;
                if (!this.Flip)
                    this.XSpeed = -2.5;
                else
                    this.XSpeed = 2.5;

                if (this.Underwater) {
                    this.XSpeed *= 0.5;
                    this.YSpeed = -2.25;
                }

                this.InvincibilityTimer = 121;
                this.Visible = 1;

                this.AnimationSpeedMult = 1.0;
                this.SetAnimation(48, 0);
                Sound.Play(this.SFX_MightyUnspin);

                this.Ground = false;
                this.JumpAbility = 0;
                this.MidAirFlag = 0;
                this.Status = this.Player_StatusMighty_UnspinInvincible;
            }

            this.JumpAbility = 0;
            if (value < 1) {
                if (this.CurrentAnimation != 48)
                    Sound.Play(this.SFX_PimPom);

                this.Unk_0x234 = 8;
            }
            return true;
        }

        if (makeInvinc != 2 || anim != 4)
            return false;

        if (this.Unk_0x234)
            return true;

        Sound.Play(this.SFX_PimPom);
        this.Unk_0x234 = 30;

        if (entity.X <= this.X)
            this.GroundSpeed = 1.0;
        else
            this.GroundSpeed = -1.0;

        return true;
    }
    event Player_LateAirUpdate() {
        if (this.CameraPtr) {
            this.CameraPtr.SetOnJump = 32.0;
            this.CameraPtr.PlayerInAir = true;
        }

        this.YSpeed += this.GravityRate;
        if (this.YSpeed < this.JumpReleaseSpeed && this.CurrentAnimation == 10 && !this.InputJump && this.JumpAbility == 1) {
            this.YSpeed = this.JumpReleaseSpeed;
            this.XSpeed = this.XSpeed - this.XSpeed / 32.0;
        }

        this.AngleMode = 0;
        this.PushingTimer = 0;

        var amount = Math_PI_DOUBLE * (4.0 / 0x200);
        var rotation = this.Rotation;
        if (rotation < 0.0)
            this.Rotation += amount;
        else if (rotation > 0.0)
            this.Rotation -= amount;
        if (Math.Abs(rotation) < amount)
            this.Rotation = 0.0;
    }

    event Player_UpdateRotation() {
        var rot = this.HexToRadians((this.Angle + 0x10) & 0xE0);
        // Classic rotation
        if (false) {
            this.Rotation = rot;

            if (this.GetAngleMode(this.Angle) == 0 && this.Ground)
                this.Rotation = 0.0;
        }
        // Mania rotation
        else {
            var angle = this.Angle;
            // print "angle: " + angle;
            if (angle <= 0x04 || angle >= 0xFC) {
                if (angle > 0x10 && angle < 0xE8)
                    this.Rotation = this.HexToRadians(angle);
                else
                    this.Rotation = 0.0;
            }
            else {
                rot = this.HexToRadians(angle);
                if (angle <= 0x10 || angle >= 0xE8)
                    rot = 0.0;

                if (Math.Abs(this.GroundSpeed) <= 6.0)
                    this.Rotation += (((rot - this.Rotation + Math_PI_DOUBLE * 1.5) % Math_PI_DOUBLE) - Math_PI) / 4.0;
                else
                    this.Rotation += (((rot - this.Rotation + Math_PI_DOUBLE * 1.5) % Math_PI_DOUBLE) - Math_PI) / 2.0;
            }
        }

        if (this.CurrentAnimation == 10)
            this.Rotation = 0.0;
    }

    event Player_ResetSpeeds() {
        var gravity;
        var isUnderwater = this.Underwater;
        var speedShoesTimer = this.SpeedShoesTimer;
        if (isUnderwater) {
            gravity = 0.125;
            if (speedShoesTimer >= 0)
                gravity = 0.0625;
        }
        else {
            gravity = 0.34375;
            if (speedShoesTimer >= 0)
                gravity = 0.21875;
        }
        this.GravityRate = gravity;

        var isSuper = this.SuperForm == 2;
        var frictionMult = 1.0;
        if (isSuper) {
            frictionMult = 0.25;
        }
        if (speedShoesTimer > 0) {
            frictionMult = 0.5;
        }
        // Custom: I don't want Speed Shoes /slowing/ down Super Forms
        if (isSuper) {
            frictionMult = 0.25;
        }

        this.TopSpeed         = 6.0;
        this.Acceleration     = 0.046875;
    	this.Friction         = 0.046875 * frictionMult;
    	this.AirAcceleration  = 0.09375;
        this.Unk_0x158        = 0.0234375;
        this.Slope            = 0.125;
    	this.SlopeRollUp      = 0.078125;
    	this.SlopeRollDown    = 0.3125;
    	this.Deceleration     = 0.5;
        this.RollFriction     = 0.0234375;
        this.JumpHeight       = this.JumpHeights[this.Character];
        this.JumpReleaseSpeed = -4.0;
        this.RollDeceleration = 0.125;

        if (isUnderwater) {
            this.TopSpeed *= 0.5;
            this.Acceleration *= 0.5;
            this.AirAcceleration *= 0.5;
            this.Deceleration *= 0.5;
            this.RollFriction *= 0.5;
        }

        if (speedShoesTimer < 0) {
            this.TopSpeed *= 0.5;
            this.Acceleration *= 0.5;
            this.AirAcceleration *= 0.5;
            this.Deceleration *= 0.5;
            this.RollFriction *= 0.5;
            this.Unk_0x158 *= 0.5;
        }

        if (this.UseChibiSprite) {
            this.TopSpeed -= this.TopSpeed / 8.0;
            this.Acceleration -= this.Acceleration / 16.0;
            this.AirAcceleration -= this.AirAcceleration / 16.0;
            this.JumpHeight -= this.JumpHeight / 8.0;
            this.JumpReleaseSpeed -= this.JumpReleaseSpeed / 8.0;
        }
    }

    event UpdateHitbox(index) {
        // if (this.StaticHitbox) {
        //
        // }
        // else {
            this.GetHitboxFromSprite(this.Sprite, this.CurrentAnimation, this.CurrentFrame, index);
        // }
    }

    // Entity
    event CheckLeftWall(x, y) {
        // -1.0, 0.0
        // -this.FloorDirection_Y, -this.FloorDirection_X
        if (this.WallSensor_Collided = this.SenseTileCollision(x, y, CollideSide_RIGHT, -this.FloorDirection_Y, -this.FloorDirection_X, -8.0, 1.0)) {
            this.WallSensor_X = Math.Floor(this.STC_X);
            this.WallSensor_Y = this.STC_Y;
            // this.WallSensor_Angle = this.STC_Angle;
            this.WallSensor_Length = this.STC_Length;
        }
        return this.WallSensor_Collided;
    }
    event CheckRightWall(x, y) {
        // Setting the end thing to 0.0 seems to make this work in air
        // 1.0, 0.0
        // this.FloorDirection_Y, this.FloorDirection_X
        if (this.WallSensor_Collided = this.SenseTileCollision(x, y, CollideSide_LEFT, this.FloorDirection_Y, this.FloorDirection_X, -8.0, 1.0)) {
            this.WallSensor_X = Math.Floor(this.STC_X);
            this.WallSensor_Y = this.STC_Y;
            // this.WallSensor_Angle = this.STC_Angle;
            this.WallSensor_Length = this.STC_Length;
        }
        return this.WallSensor_Collided;
    }
    event CheckCeilLeftSensor(x, y) {
        if (this.LeftCeilSensor_Collided = this.SenseTileCollision(x, y, this.FloorSensor_Side ^ 5, this.FloorDirection_X, -this.FloorDirection_Y, -10.0, 0.0)) {
            this.LeftCeilSensor_X = this.STC_X;
            this.LeftCeilSensor_Y = this.STC_Y;
            this.LeftCeilSensor_Angle = this.STC_Angle;
            this.LeftCeilSensor_Length = this.STC_Length;
        }
        return this.LeftCeilSensor_Collided;
    }
    event CheckCeilRightSensor(x, y) {
        if (this.RightCeilSensor_Collided = this.SenseTileCollision(x, y, this.FloorSensor_Side ^ 5, this.FloorDirection_X, -this.FloorDirection_Y, -10.0, 0.0)) {
            this.RightCeilSensor_X = this.STC_X;
            this.RightCeilSensor_Y = this.STC_Y;
            this.RightCeilSensor_Angle = this.STC_Angle;
            this.RightCeilSensor_Length = this.STC_Length;
        }
        return this.RightCeilSensor_Collided;
    }
    event CheckFloorLeftSensor(x, y, initialAngle) {
        if (this.LeftSensor_Collided = this.SenseTileCollision(x, y, 0x10 | this.FloorSensor_Side, this.FloorDirection_X, this.FloorDirection_Y, -14.0, this.MaxTileCollision)) {
            if (initialAngle != -1 &&
                Math.Abs(((initialAngle - this.STC_Angle + 0x80) & 0xFF) - 0x80) > 0x20) {
                return this.LeftSensor_Collided = false;
            }
            if (this.STC_Length <= -14.0)
                return this.LeftSensor_Collided = false;
            this.LeftSensor_X = this.STC_X;
            this.LeftSensor_Y = this.STC_Y;
            this.LeftSensor_Angle = this.STC_Angle;
            this.LeftSensor_Length = this.STC_Length;
        }
        return this.LeftSensor_Collided;
    }
    event CheckFloorMiddleSensor(x, y, initialAngle) {
        if (this.MiddleSensor_Collided = this.SenseTileCollision(x, y, 0x10 | this.FloorSensor_Side, this.FloorDirection_X, this.FloorDirection_Y, -14.0, this.MaxTileCollision)) {
            if (initialAngle != -1 &&
                Math.Abs(((initialAngle - this.STC_Angle + 0x80) & 0xFF) - 0x80) > 0x20) {
                return this.MiddleSensor_Collided = false;
            }
            if (this.STC_Length <= -14.0)
                return this.MiddleSensor_Collided = false;
            this.MiddleSensor_X = this.STC_X;
            this.MiddleSensor_Y = this.STC_Y;
            this.MiddleSensor_Angle = this.STC_Angle;
            this.MiddleSensor_Length = this.STC_Length;
        }
        return this.MiddleSensor_Collided;
    }
    event CheckFloorRightSensor(x, y, initialAngle) {
        if (this.RightSensor_Collided = this.SenseTileCollision(x, y, 0x10 | this.FloorSensor_Side, this.FloorDirection_X, this.FloorDirection_Y, -14.0, this.MaxTileCollision)) {
            if (initialAngle != -1 &&
                Math.Abs(((initialAngle - this.STC_Angle + 0x80) & 0xFF) - 0x80) > 0x20) {
                return this.RightSensor_Collided = false;
            }
            if (this.STC_Length <= -14.0)
                return this.RightSensor_Collided = false;
            this.RightSensor_X = this.STC_X;
            this.RightSensor_Y = this.STC_Y;
            this.RightSensor_Angle = this.STC_Angle;
            this.RightSensor_Length = this.STC_Length;
        }
        return this.RightSensor_Collided;
    }
    event SenseTileCollision(x, y, side, dirX, dirY, startLen, endLen) {
        x += dirX * startLen;
        y += dirY * startLen;

        var angle;
        for (var i = startLen; i < endLen; i += 1.0) {
            angle = TileCollision.PointExtended(x, y, this.PlaneIndex, side);
            if (angle >= 0) {
                this.STC_X = Math.Floor(x);
                this.STC_Y = Math.Floor(y);
                this.STC_Angle = angle;
                this.STC_Length = i;
                return true;
            }

            x += dirX;
            y += dirY;
        }
        return false;
    }
    event InitGroundSensors(initialX, initialY, initialAngle, angleMode) {
        var floor_sensor_cos = this.SensorABCD_Ground_cos;
        var floor_sensor_sin = this.SensorABCD_Ground_sin;
        var wall_sensor_cos = this.SensorEF_cos;
        var wall_sensor_sin = this.SensorEF_sin;
        var simple_cos = this.simple_cos;
        var simple_sin = this.simple_sin;
        var simple_side = this.simple_side;

        this.FloorDirection_X = simple_sin[angleMode];
        this.FloorDirection_Y = simple_cos[angleMode];
        this.FloorSensor_Side = simple_side[angleMode];

        var wall_x = initialX;
        var wall_y = initialY + this.CheckCenterOffY;
        // 1 | 3
        if (angleMode & 1)
            wall_y = initialY;

        var foot_x = initialX + this.HitboxHalfH * this.FloorDirection_X;
        var foot_y = initialY + this.HitboxHalfH * this.FloorDirection_Y;
        this.LeftSensor_X = foot_x - floor_sensor_cos[angleMode];
        this.LeftSensor_Y = foot_y - floor_sensor_sin[angleMode];
        this.RightSensor_X = foot_x + floor_sensor_cos[angleMode];
        this.RightSensor_Y = foot_y + floor_sensor_sin[angleMode];
        this.MiddleSensor_X = foot_x;
        this.MiddleSensor_Y = foot_y;
        if (this.GroundSpeed <= 0.0) {
            this.WallSensor_X = wall_x - wall_sensor_cos[angleMode] - 1.0;
            this.WallSensor_Y = wall_y - wall_sensor_sin[angleMode];
        }
        else {
            this.WallSensor_X = wall_x + wall_sensor_cos[angleMode];
            this.WallSensor_Y = wall_y + wall_sensor_sin[angleMode];
        }
        this.LeftSensor_Angle =
            this.RightSensor_Angle =
            this.MiddleSensor_Angle = initialAngle;
        this.LeftSensor_Length =
            this.RightSensor_Length =
            this.MiddleSensor_Length = 0;
        this.LeftSensor_Collided =
            this.RightSensor_Collided =
            this.MiddleSensor_Collided =
            this.WallSensor_Collided = false;
    }
    event InitAirSensors(initialX, initialY) {
        var floor_sensor_cos = this.SensorEF_cos; // this.SensorABCD_Air_cos;
        var floor_sensor_sin = this.SensorEF_sin; // this.SensorABCD_Air_sin;
        var wall_sensor_cos = this.SensorEF_cos;
        var wall_sensor_sin = this.SensorEF_sin;
        var simple_cos = this.simple_cos;
        var simple_sin = this.simple_sin;
        var simple_side = this.simple_side;

        this.FloorDirection_X = 0.0;
        this.FloorDirection_Y = 1.0;
        this.FloorSensor_Side = CollideSide_TOP;

        var wall_x = initialX;
        var wall_y = initialY + this.CheckCenterOffY;
        var foot_x = initialX;
        var foot_y = initialY + this.HitboxHalfH;
        var head_x = initialX;
        var head_y = initialY - this.HitboxHalfH - 1.0;

        // Moving right
        if (this.XSpeed >= 0.0) {
            this.WallSensor_X = wall_x + wall_sensor_cos[0];
            this.WallSensor_Y = wall_y;
        }
        // Moving left
        if (this.XSpeed <= 0.0) {
            this.WallSensor_X = wall_x - wall_sensor_cos[0] - 1.0;
            this.WallSensor_Y = wall_y;
        }

        // Moving down
        this.LeftSensor_X = foot_x - floor_sensor_cos[0] + 1;
        this.LeftSensor_Y = foot_y;
        this.RightSensor_X = foot_x + floor_sensor_cos[0] - 2;
        this.RightSensor_Y = foot_y;

        this.LeftCeilSensor_X = head_x - floor_sensor_cos[0] + 1;
        this.LeftCeilSensor_Y = head_y;
        this.RightCeilSensor_X = head_x + floor_sensor_cos[0] - 2;
        this.RightCeilSensor_Y = head_y;

        this.LeftSensor_Angle =
            this.RightSensor_Angle =
            this.LeftCeilSensor_Angle =
            this.RightCeilSensor_Angle = 0;
        this.LeftSensor_Collided =
            this.RightSensor_Collided =
            this.LeftCeilSensor_Collided =
            this.RightCeilSensor_Collided =
            this.WallSensor_Collided = false;
    }
    event Entity_GroundMovement() {
        // NOTE: More parts = more precision & more CPU usage
        //    Mania uses 4.0, we will use 4.0 until otherwise.
        var parts = 4.0;

        var groundSpeed = Math.Abs(this.GroundSpeed);
        var speedPart = Math.Floor(groundSpeed / parts);
        var speedFraction = groundSpeed - speedPart * parts;
        var speedPartRemain = speedFraction;

        var angle, angleMode, gsp, cos, sin, deltaX, deltaY;

        var initialX = this.X;
        var initialY = this.Y;
        var initialAngle = this.Angle;

        var wall_sensor_cos = this.SensorEF_cos;
        var wall_sensor_sin = this.SensorEF_sin;

        var sensorsAngle = this.sensorsAngle;
        var sensorsLength = this.sensorsLength;
        var sensorsCollided = this.sensorsCollided;

        gsp = this.GroundSpeed;

        this.InitGroundSensors(initialX, initialY, initialAngle, this.AngleMode);

        var count = 0;
        while (speedPartRemain >= 0.0) {
            angle = this.Angle;
            angleMode = this.AngleMode;
            cos = Static.HexCos(angle);
            sin = Static.HexSin(angle);
            if (speedPart > 0.0) {
                deltaX = cos * parts;
                deltaY = sin * parts;
                speedPartRemain = speedPart - 1.0;
            }
            else {
                deltaX = speedFraction * cos;
                deltaY = speedFraction * sin;
                speedPartRemain = -1.0;
            }

            if (gsp < 0.0) {
                deltaX = -deltaX;
                deltaY = -deltaY;
            }

            // if (!this.WallSensor_Collided)
            this.InitGroundSensors(initialX, initialY, initialAngle, angleMode);

            initialX += deltaX;
            initialY += deltaY;

            // TODO: Fix
            // Check Walls here
            if (gsp <= 0) {
                // CheckLeftWall, max left 0xE past hitbox
                if (angleMode == 0)
                if (this.CheckLeftWall(this.WallSensor_X, this.WallSensor_Y)) {
                    speedPartRemain = -1;
                    if (!(angleMode & 1))
                        deltaX = 0.0;
                    else
                        deltaY = 0.0;
                    if (angleMode == 0)
                        this.LeftSensor_X = this.WallSensor_X + 2.0;
                }
            }
            else {
                // CheckRightWall
                if (angleMode == 0)
                if (this.CheckRightWall(this.WallSensor_X, this.WallSensor_Y)) {
                    speedPartRemain = -1;
                    if (!(angleMode & 1))
                        deltaX = 0.0;
                    else
                        deltaY = 0.0;
                    if (angleMode == 0)
                        this.RightSensor_X = this.WallSensor_X - 2.0;
                }
            }

            // if (angleMode != 0) {
            //     print "this.Angle: " + this.Angle;
            //     print "initialAngle: " + initialAngle;
            // }

            // Check Floor here
            this.LeftSensor_X += deltaX;
            this.MiddleSensor_X += deltaX;
            this.RightSensor_X += deltaX;
            this.LeftSensor_Y += deltaY;
            this.MiddleSensor_Y += deltaY;
            this.RightSensor_Y += deltaY;
            this.CheckFloorLeftSensor(this.LeftSensor_X, this.LeftSensor_Y, initialAngle);
            this.CheckFloorMiddleSensor(this.MiddleSensor_X, this.MiddleSensor_Y, initialAngle);
            this.CheckFloorRightSensor(this.RightSensor_X, this.RightSensor_Y, initialAngle);

            // Determine sensor to use
            var highestSensor = -1;
            sensorsAngle[0] = this.LeftSensor_Angle;
            sensorsAngle[1] = this.MiddleSensor_Angle;
            sensorsAngle[2] = this.RightSensor_Angle;
            sensorsLength[0] = this.LeftSensor_Length;
            sensorsLength[1] = this.MiddleSensor_Length;
            sensorsLength[2] = this.RightSensor_Length;
            sensorsCollided[0] = this.LeftSensor_Collided;
            sensorsCollided[1] = this.MiddleSensor_Collided;
            sensorsCollided[2] = this.RightSensor_Collided;

            // Get highest sensor
            for (var i = 0; i < 3; i++) {
                if (highestSensor == -1) {
                    if (sensorsCollided[i])
                        highestSensor = i;
                }
                else if (sensorsCollided[i]) {
                    var currentLen = sensorsLength[i];
                    var highestLen = sensorsLength[highestSensor];

                    // if (angleMode != 0) {
                    //     print "sensorsAngle["+i+"]: " + sensorsAngle[i];
                    //     print "sensorsLength["+i+"]: " + sensorsLength[i];
                    // }

                    if (currentLen < highestLen) {
                        highestSensor = i;
                    }
                    else if (currentLen == highestLen) {
                        var currentAngle = sensorsAngle[i];
                        if (angleMode == 0) {
                            if (currentAngle < 0x08 || currentAngle > 0xF8)
                                highestSensor = i;
                        }
                        else {
                            highestSensor = i;
                        }
                    }
                }
            }

            // Set future positions
            var finalAngle = -1;
            if (highestSensor == -1) {
                finalAngle = initialAngle;
                speedPartRemain = -1;
            }
            else {
                finalAngle = sensorsAngle[highestSensor];
                initialX += sensorsLength[highestSensor] * this.FloorDirection_X;
                initialY += sensorsLength[highestSensor] * this.FloorDirection_Y;
            }

            // Change AngleMode
            // For some reason the AngleMode used in Mania and 3K is so different
            // if (3KBased) this.AngleMode = this.GetAngleMode(this.Angle ^ 0xFF) >> 6;
            // var lastAngleMode = this.AngleMode;
            if (this.AngleMode == 0) { // 0x00 +/- 0x22
                if (((finalAngle + 0x7F) & 0xFF) <= 0x5C)
                    this.AngleMode = 1;
                if (((finalAngle - 0x23 + 0x100) & 0xFF) <= 0x5C)
                    this.AngleMode = 3;
            }
            else if (this.AngleMode == 1) { // 0xC0 +/- 0x22
                if (finalAngle > 0xE2)
                    this.AngleMode = 0;
                if (finalAngle < 0x9E)
                    this.AngleMode = 2;
            }
            else if (this.AngleMode == 2) { // 0x80 +/- 0x22
                if (finalAngle > 0xA2)
                    this.AngleMode = 1;
                if (finalAngle < 0x5E)
                    this.AngleMode = 3;
            }
            else if (this.AngleMode == 3) { // 0x40 +/- 0x22
                if (finalAngle > 0x62)
                    this.AngleMode = 2;
                if (finalAngle < 0x1E)
                    this.AngleMode = 0;
            }

            // if (this.AngleMode != lastAngleMode) {
            //     print "this.AngleMode: " + lastAngleMode + " -> " + this.AngleMode;
            // }

            if (this.WallSensor_Collided)
                break;

            // if (highestSensor != -1) {
                this.Angle = finalAngle;
            // }

            speedPart = speedPartRemain;
        }

        // On floor?
        if (this.LeftSensor_Collided || this.MiddleSensor_Collided || this.RightSensor_Collided) {
            if (this.WallSensor_Collided) {
                // TODO: Make these AngleMode agnostic
                if (gsp < 0.0) {
                    this.X = this.WallSensor_X + wall_sensor_cos[angleMode] + 1.0;
                    this.Y = initialY;
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                }
                else if (gsp > 0.0) {
                    this.X = this.WallSensor_X - wall_sensor_cos[angleMode];
                    this.Y = initialY;
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                }
                else {
                    this.Y = initialY;
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                }
            }
            else {
                this.X = initialX;
                this.Y = initialY;
            }
        }
        // Not on floor
        else {
            this.Ground = false;

            this.XSpeed = this.GroundSpeed * Static.HexCos(this.Angle);
            this.YSpeed = this.GroundSpeed * Static.HexSin(this.Angle);

            this.YSpeed = Math.Clamp(this.YSpeed, -16.0, 16.0);

            this.GroundSpeed = this.XSpeed;
            this.Angle = 0;
            this.AngleMode = 0;
            if (this.WallSensor_Collided) {
                if (this.XSpeed < 0.0) {
                    this.X = this.WallSensor_X + wall_sensor_cos[angleMode] + 1.0;
                    this.Y += this.YSpeed;
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                }
                else if (this.XSpeed > 0.0) {
                    this.X = this.WallSensor_X - wall_sensor_cos[angleMode];
                    this.Y += this.YSpeed;
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                }
                else {
                    this.Y += this.YSpeed;
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                }
            }
            else {
                this.X += this.XSpeed;
                this.Y += this.YSpeed;
            }
        }
    }
    event Entity_AirMovement() {
        var movingUp = false;
        var movingDown = false;
        var movingLeft = false;
        var movingRight = false;

        var xspeed = this.XSpeed;
        var yspeed = this.YSpeed;

        // NOTE: This is a custom addition
        this.Angle = 0;
        this.AngleMode = 0;
        // this.HitboxHalfH = 15.0;

        // Determine if moving right
        if (xspeed >= 0.0) {
            movingRight = true;
        }
        if (xspeed <= 0.0) {
            movingLeft = true;
        }
        if (yspeed >= 0.0) {
            movingDown = true;
        }
        if (Math.Abs(xspeed) > 1.0 || yspeed <= 0.0) {
            movingUp = true;
        }

        // var doSensor;
        var absXSpeed = Math.Abs(xspeed);
        var absYSpeed = Math.Abs(yspeed);
        var absMaxSpeed = Math.Max(absXSpeed, absYSpeed);
        var speedDivisor = ((Number.AsInteger(absMaxSpeed) << 16) >> this.SpeedPartitionValue) + 1.0;
        var xspeedPart = xspeed / speedDivisor;
        var yspeedPart = yspeed / speedDivisor;
        var xspeedFraction = xspeed - xspeedPart * (speedDivisor - 1.0);
        var yspeedFraction = yspeed - yspeedPart * (speedDivisor - 1.0);

        var originalXSpeed = this.XSpeed;

        var speedPartRemain, deltaX, deltaY;
        if (speedDivisor > 0) {
            deltaX = deltaY = 0.0;
            while (true) {
                if (speedDivisor >= 2.0) {
                    deltaX += xspeedPart;
                    deltaY += yspeedPart;
                }
                else {
                    deltaX += xspeedFraction;
                    deltaY += yspeedFraction;
                }
                speedPartRemain = speedDivisor - 1.0;

                this.InitAirSensors(this.X + deltaX, this.Y + deltaY);

                // print "Y: " + (this.Y + deltaY);
                // print "this.LeftSensor_Y: " + this.LeftSensor_Y;
                // print "distance: " + (this.LeftSensor_Y - (this.Y + deltaY));

                // Check for right wall collision
                if (movingRight == 1) {
                    if (this.CheckRightWall(this.WallSensor_X, this.WallSensor_Y)) {
                        movingRight = 2;
                    }
                    else if (this.XSpeed < 2.0 && this.CheckCenterOffY > 0.0) {
                        if (this.CheckRightWall(this.WallSensor_X, this.WallSensor_Y - 2.0 * this.CheckCenterOffY))
                            movingRight = 2;
                    }
                }

                // Check for left wall collision
                if (movingLeft == 1) {
                    if (this.CheckLeftWall(this.WallSensor_X, this.WallSensor_Y)) {
                        movingLeft = 2;
                    }
                    else if (this.XSpeed > -2.0 && this.CheckCenterOffY > 0.0) {
                        if (this.CheckLeftWall(this.WallSensor_X, this.WallSensor_Y - 2.0 * this.CheckCenterOffY))
                            movingLeft = 2;
                    }
                }

                // If there was a right wall collision
                if (movingRight == 2) {
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                    this.X = this.WallSensor_X - this.SensorEF_cos[0];
                    this.LeftSensor_X = this.LeftCeilSensor_X = this.X - this.SensorEF_cos[0] + 1.0;
                    this.RightSensor_X = this.RightCeilSensor_X = this.X + this.SensorEF_cos[0] - 2.0;
                    // print "right wall (x: " + this.X + " wx: " + this.WallSensor_X + " ef: " + this.SensorEF_cos[0] + " rx: " + this.RightSensor_X + ")";
                    movingRight = 3;
                    speedPartRemain = 0.0;
                }

                // If there was a left wall collision
                if (movingLeft == 2) {
                    this.XSpeed = 0.0;
                    this.GroundSpeed = 0.0;
                    this.X = this.WallSensor_X + this.SensorEF_cos[0] + 1.0;
                    this.LeftSensor_X = this.LeftCeilSensor_X = this.X - this.SensorEF_cos[0] + 1.0;
                    this.RightSensor_X = this.RightCeilSensor_X = this.X + this.SensorEF_cos[0] - 2.0;
                    movingLeft = 3;
                    speedPartRemain = 0.0;
                }

                // If moving down
                if (movingDown == 1) {
                    var gh = this.MaxTileCollision;

                    this.MaxTileCollision = 0.0;

                    var ls = this.LeftSensor_Y;
                    var rs = this.RightSensor_Y;

                    if (this.CheckFloorLeftSensor(this.LeftSensor_X, this.LeftSensor_Y, -1)) {
                        movingDown = 2;
                        speedPartRemain = 0;

                        // print "left side collision (x: " + this.LeftSensor_X + ", y: " + this.LeftSensor_Y + ", ang: " + Number.ToString(this.LeftSensor_Angle, 16) + ")";
                    }
                    if (this.CheckFloorRightSensor(this.RightSensor_X, this.RightSensor_Y, -1)) {
                        movingDown = 2;
                        speedPartRemain = 0;

                        // print "right side collision (x: " + this.RightSensor_X + ", y: " + this.RightSensor_Y + ", ang: " + Number.ToString(this.RightSensor_Angle, 16) + ")";
                    }

                    this.MaxTileCollision = gh;
                }

                // If moving up
                if (movingUp == 1) {
                    if (this.CheckCeilLeftSensor(this.LeftCeilSensor_X, this.LeftCeilSensor_Y)) {
                        movingUp = 2;
                        speedPartRemain = 0;
                    }
                    if (this.CheckCeilRightSensor(this.RightCeilSensor_X, this.RightCeilSensor_Y)) {
                        movingUp = 2;
                        speedPartRemain = 0;
                    }
                }

                speedDivisor = speedPartRemain;
                if (speedPartRemain <= 0.0)
                    break;
            }
        }

        if (movingLeft == 3) {
            // print "hit left movingDown: " + movingDown +
            //     " xspeed: " + xspeed +
            //     " yspeed: " + yspeed;
        }

        // If no collisions, just move
        if (movingRight < 2 && movingLeft < 2) {
            this.X += this.XSpeed;
        }
        if (movingDown < 2 && movingUp < 2) {
            this.Y += this.YSpeed;
            return;
        }

        // If moving down and collided
        if (movingDown == 2) {
            this.Ground = true;

            var doSensor;
            if (this.LeftSensor_Collided && this.RightSensor_Collided)
                doSensor = this.LeftSensor_Length < this.RightSensor_Length ? -1 : 1;
            else if (this.LeftSensor_Collided && !this.RightSensor_Collided)
                doSensor = -1;
            else
                doSensor = 1;

            if (doSensor == -1) {
                if (movingLeft == 3 || movingRight == 3)
                    this.XSpeed = originalXSpeed;
                this.Y = this.LeftSensor_Y - this.HitboxHalfH;
                this.Angle = this.LeftSensor_Angle;
                this.Entity_AirMovementDownwards_Angles();
            }
            else if (doSensor == 1) {
                if (movingLeft == 3 || movingRight == 3)
                    this.XSpeed = originalXSpeed;
                this.Y = this.RightSensor_Y - this.HitboxHalfH;
                this.Angle = this.RightSensor_Angle;
                this.Entity_AirMovementDownwards_Angles();
            }
        }

        // If moving up and collided
        if (movingUp == 2) {
            var doSensor;
            if (this.LeftCeilSensor_Collided && this.RightCeilSensor_Collided)
                doSensor = this.LeftCeilSensor_Length < this.RightCeilSensor_Length ? -1 : 1;
            else if (this.LeftCeilSensor_Collided && !this.RightCeilSensor_Collided)
                doSensor = -1;
            else
                doSensor = 1;

            if (doSensor == -1) {
                // if (movingLeft == 3 || movingRight == 3)
                //     this.XSpeed = originalXSpeed;

                this.Y = this.LeftCeilSensor_Y + this.HitboxHalfH + 1.0;
                this.Entity_AirMovementUpwards_Angles(this.LeftCeilSensor_Angle);
            }
            else if (doSensor == 1) {
                // if (movingLeft == 3 || movingRight == 3)
                //     this.XSpeed = originalXSpeed;

                this.Y = this.RightCeilSensor_Y + this.HitboxHalfH + 1.0;
                this.Entity_AirMovementUpwards_Angles(this.RightCeilSensor_Angle);
            }
        }
    }
    event Entity_AirMovementDownwards_Angles() {
        var angle = this.Angle;
        var angleMode = this.AngleMode;
        // Setting angle modes
        if (angle > 0xA0 && angle < 0xDE && angleMode != 1) {
            this.X -= 4.0;
            this.AngleMode = 1;
        }
        if (angle > 0x22 && angle < 0x60 && angleMode != 3) {
            this.X += 4.0;
            this.AngleMode = 3;
        }

        //
        var xspeed = this.XSpeed;
        var yspeed = this.YSpeed;

        // print "xspeed: " + xspeed;

        var gspeed = xspeed;
        var absXSpeed = Math.Abs(xspeed);
        var absYSpeed = Math.Abs(yspeed);
        var absYSpeedHalf = absYSpeed * 0.5;
        var sign = Math.Sign(Static.HexSin(angle));
        if (angle >= 0x80) {
            // Full Steep
            if (angle <= 0xE0) {
                if (absXSpeed <= absYSpeed)
                    gspeed = -yspeed;
            }
            // Half Steep
            else if (angle <= 0xF0) {
                if (absXSpeed <= absYSpeedHalf)
                    gspeed = -yspeed * 0.5;
            }
            // Shallow
            else {
                gspeed = xspeed;
            }
        }
        else {
            // Full Steep
            if (angle >= 0x20) {
                if (absXSpeed <= absYSpeed)
                    gspeed = yspeed;
            }
            // Half Steep
            else if (angle >= 0x10) {
                if (absXSpeed <= absYSpeedHalf)
                    gspeed = yspeed * 0.5;
            }
            // Shallow
            else {
                gspeed = xspeed;
            }
        }

        // print "angle: " + angle;
        // print "gspeed: " + gspeed;

        // Clamp Speeds
        this.GroundSpeed = gspeed;
        this.XSpeed = gspeed;
        this.YSpeed = 0.0;
    }
    event Entity_AirMovementUpwards_Angles(angle) {
        var xspeed = this.XSpeed;
        var yspeed = this.YSpeed;

        var gspeed = xspeed;
        var absXSpeed = Math.Abs(xspeed);
        var absYSpeed = Math.Abs(yspeed);

        // Upward Slope (Right)
        if (angle >= 0x9F && angle <= 0xC0) {
            if (yspeed < -absXSpeed) {
                this.X -= 4.0;
                this.Y -= 2.0;
                this.Ground = true;
                this.Angle = angle;
                this.AngleMode = 1;

                gspeed = -yspeed;
                if (angle <= 0x9F)
                    gspeed *= 0.5;

                this.GroundSpeed = gspeed;
                print "this.GroundSpeed: " + this.GroundSpeed;
            }
        }
        // Upward Slope (Left)
        else if (angle >= 0x40 && angle <= 0x61) {
            if (yspeed < -absXSpeed) {
                this.X += 4.0;
                this.Y -= 2.0;
                this.Ground = true;
                this.Angle = angle;
                this.AngleMode = 3;

                gspeed = yspeed;
                if (angle >= 0x61)
                    gspeed *= 0.5;

                this.GroundSpeed = gspeed;
            }
        }

        if (this.YSpeed < 0.0)
            this.YSpeed = 0.0;
    }

    event Entity_ApplyPhysics() {
        if (this.UseGroundSpeed) {
            this.Angle &= 0xFF;

            if (Math.Abs(this.GroundSpeed) >= 6.0)
                this.MaxTileCollision = 15;
            else if (this.Angle != 0)
                this.MaxTileCollision = 15;
            else
                this.MaxTileCollision = 8;

            this.CheckCenterOffY = 0.0;
            if (this.HitboxHalfH >= 14.0) {
                this.CheckCenterOffY = 4.0;
                this.SpeedPartitionValue = 19;
            }
            else {
                this.CheckCenterOffY = 0.0;
                this.SpeedPartitionValue = 17;
                this.MaxTileCollision = 15;
            }

            if (this.Ground)
                this.Entity_GroundMovement();
            else
                this.Entity_AirMovement();

            if (this.Ground) {
                this.XSpeed = this.GroundSpeed * Static.HexCos(this.Angle);
                this.YSpeed = this.GroundSpeed * Static.HexSin(this.Angle);
            }
            else {
                this.GroundSpeed = this.XSpeed;
            }
        }
        else {
            this.X += this.XSpeed;
            this.Y += this.YSpeed;
        }
    }
    event Entity_CanFindTile(a2, sensorMode, planeIndex, x, y, len) {
        var side = CollideSide_TOP;
        if (sensorMode == 0)
            side = CollideSide_TOP;
        else if (sensorMode == 1)
            side = CollideSide_LEFT;
        else if (sensorMode == 2)
            side = CollideSide_BOTTOM;
        else if (sensorMode == 3)
            side = CollideSide_RIGHT;

        var startX = Math.Floor(this.X + x);
        var startY = Math.Floor(this.Y + y);
        for (var i = 0; i < len; i++) {
            if (TileCollision.PointExtended(startX, startY, planeIndex, side) >= 0)
                return true;

            startY += 1.0;
        }
        return false;
    }

    // Update functions
    event Update() {
        if (!this.CameraPtr) {
            this.CameraPtr = Instance.GetNth("Camera", 0);
            if (this.CameraPtr) {
                this.CameraPtr.PlayerPtr = this;
            }
            else {
                this.CameraPtr = Instance.Create("Camera", this.X, this.Y);
                this.CameraPtr.PlayerPtr = this;
            }
        }

        this.GetInput();

        var camera = this.CameraPtr;
        if (camera) {
            var blockCameraLookTimer = this.CameraLockTimer;
            if (blockCameraLookTimer > 0) {
                this.CameraLockTimer = blockCameraLookTimer - 1;
                if (blockCameraLookTimer == 1)
                    camera.Status = camera.Camera_StatusNormal;
            }
            else {
                var playerStatus = this.Status;
                if (playerStatus != this.Player_StatusLookingUp && playerStatus != this.Player_StatusLookingDown) {
                    var cameraOffY = camera.OffsetY;
                    if (cameraOffY > 0.0) {
                        camera.OffsetY = cameraOffY - 2.0;
                    }
                    if (cameraOffY < 0.0) {
                        camera.OffsetY = cameraOffY + 2.0;
                    }
                }
            }
        }

        var invincibility = this.Invincibility;
        if (invincibility) {
            if (invincibility < 0) {
                this.Invincibility = invincibility + 1;
            }
            else {
                this.Invincibility = invincibility - 1;
                if (invincibility == 1) {
                    //
                }
            }
        }

        var speedshoestimer = this.SpeedShoesTimer;
        if (speedshoestimer > 0) {
            this.SpeedShoesTimer = speedshoestimer - 1;
            if (speedshoestimer == 1) {

            }
        }

        if (this.Status != this.Player_StatusHurt) {
            var invincibilityFrames = this.InvincibilityTimer;
            if (invincibilityFrames > 0) {
                invincibilityFrames--;
                this.InvincibilityTimer = invincibilityFrames;
                this.Visible = (invincibilityFrames & 4) == 0;
            }
        }

        // Is being crushed?
        if (this.HorizontalCollisionFlag == 3 || this.VerticalCollisionFlag == 3)
            this.KillPlayer();

        this.HorizontalCollisionFlag = 0;
        this.VerticalCollisionFlag = 0;

        // Run main code
        this.Status();

        // this.HitboxW = this.HitboxHalfW * 2.0;
        // this.HitboxH = this.HitboxHalfH * 2.0;

        this.GetHitboxFromSprite(this.Sprite, this.CurrentAnimation, this.CurrentFrame, 1);
        this.HitboxHalfH = this.HitboxOffY + this.HitboxH * 0.5;

        // if (true) {
            this.GroundSensorMask = 0;
            // this.IsUpsideDown = false;
            // if (true) {
                this.Entity_ApplyPhysics();
            // }
            // else {
            //
            // }

            if (this.Ground && this.AngleMode == 0)
                this.VerticalCollisionFlag |= 1;
        // }

        // this.HitboxW = this.HitboxHalfW * 2.0;
        // this.HitboxH = this.HitboxHalfH * 2.0;

        if (!this.StopTimer)
            this.TimerFrames++;
    }
    event UpdateLate() {
        if (this.KillFlag) {
            this.MaxGlideSpeed = 0.0;
            // TODO:
            // if (this.GravityRate < 0.0)
            //     this.FlipFlag |= 2;
            // else
            //     this.FlipFlag &= 1;
            this.Visible = true;
            this.Ground = false;
            this.GroundSpeed = 0.0;
            this.XSpeed = 0.0;
            this.LateUpdateGroundStatus = null;
            this.LateUpdateAirStatus = null;
            this.UseGroundSpeed = false;
            //
            this.Shield = ShieldType_NONE;
            this.HorizontalCollisionFlag = 0;
            this.VerticalCollisionFlag = 0;
            this.Underwater = false;
            this.Player_ResetSpeeds();
            //

            this.CameraLockTimer = 1000000;
            if (this.CameraPtr)
                this.CameraPtr.Status = null;
            this.KillFlag = false;
            this.YSpeed = -6.5;
            this.Status = this.Player_StatusDead;
        }

        if (this.Ground) {
            if (this.LateUpdateGroundStatus) {
                this.Status = this.LateUpdateGroundStatus;
                this.LateUpdateGroundStatus = null;
                //
                this.EnemyCombo = 0;
            }

            var camera = this.CameraPtr;
            if (camera) {
                if (this.CurrentAnimation == 10)
                    camera.Camera_Unk_0x9C = this.RollHitboxDelta;
                else
                    camera.Camera_Unk_0x9C = 0.0;
            }
        }
        else if (this.LateUpdateAirStatus) {
            this.Status = this.LateUpdateAirStatus;
            this.LateUpdateAirStatus = null;
        }

        // Do Tails Rotation Updating here if we have tailsprite
        var tailObject = this.TailObject;
        if (this.Character == Character_TAILS && tailObject) {
            this.ShowingTailSprite = true;
            switch (this.CurrentAnimation) {
                case 0:
                case 1:
                case 3:
                case 4:
                    // 0
                    tailObject.SetAnimation(0, 0);
                    this.TailFlip = this.Flip;
                    this.TailRotation = this.Rotation;
                    break;
                case 10:
                    // 1
                    tailObject.SetAnimation(1, 0);
                    if (this.Ground) {
                        this.TailFlip = this.GroundSpeed <= 0.0;
                        this.TailRotation = Math.Atan(this.XSpeed, this.YSpeed);
                        if (this.TailFlip)
                            this.TailRotation -= Math_PI;
                    }
                    else {
                        this.TailFlip = this.Flip;
                        this.TailRotation = Math.Atan(this.XSpeed, this.YSpeed);
                        if (this.Flip)
                            this.TailRotation -= Math_PI;
                    }
                    break;
                case 15:
                    // 2
                    tailObject.SetAnimation(2, 0);
                    this.TailFlip = this.Flip;
                    break;
                case 13:
                case 17:
                case 28:
                    // 3
                    tailObject.SetAnimation(3, 0);
                    this.TailFlip = this.Flip;
                    break;
                case 29:
                    // 4
                    tailObject.SetAnimation(4, 0);
                    this.TailFlip = this.Flip;
                    break;
                case 37:
                    // 5
                    tailObject.SetAnimation(5, 0);
                    this.TailFlip = this.Flip;
                    this.TailRotation = this.Rotation;
                    if (this.Flip)
                        this.TailRotation += Math_PI_DOUBLE / 16.0;
                    else
                        this.TailRotation -= Math_PI_DOUBLE / 16.0;
                    break;
                default:
                    this.ShowingTailSprite = false;
                    break;
            }
            tailObject.Animate();
        }
    }

    // Render functions
    event Render() {
        var drawPlayer = (this.InvulnTimer % 6) < 3;
        if (this.Visible) {
            Draw.Save();
            Draw.Translate(Math.Floor(this.X), Math.Floor(this.Y), 0.0);
                var shield = this.ShieldObject;
                // Draw shield behind if behind
                if (this.Shield != ShieldType_NONE && shield && shield.Behind && !shield.Hidden) {
                    Draw.SetBlendMode(shield.BlendMode);
                    Draw.SetTextureBlend(true);
                    Draw.SetBlendColor(1.0, 1.0, 1.0, shield.Alpha);
                    Draw.Sprite(shield.Sprite, shield.CurrentAnimation, shield.CurrentFrame, 0.0, 0.0, shield.Flip, false);
                    Draw.SetTextureBlend(false);
                    Draw.SetBlendMode(BlendMode_NORMAL);
                }

                if (drawPlayer) {
                    // Draw tail sprites
                    if (this.Character == Character_TAILS && this.ShowingTailSprite && !this.KillFlag) {
                        var tails = this.TailObject;

                        Draw.Save();
                        Draw.Rotate(0.0, 0.0, this.TailRotation);
                            Draw.Sprite(tails.Sprite, tails.CurrentAnimation, tails.CurrentFrame, 0.0, 0.0, this.TailFlip, false);
                        Draw.Restore();
                    }

                    // Draw player sprite
                    Draw.Save();
                    Draw.Rotate(0.0, 0.0, this.Rotation);
                        Draw.Sprite(this.Sprite, this.CurrentAnimation, this.CurrentFrame, 0.0, 0.0, this.Flip, false);
                    Draw.Restore();
                }

                // Draw spindash dust
                if (this.Status == this.Player_StatusSpinDash && !this.KillFlag)
                    Draw.Sprite(this.DashDustSprite, 1, this.DashDustTimer, 0.0, this.HitboxHalfH, this.Flip, false);

                // Draw shield in front if not behind
                if (this.Shield != ShieldType_NONE && shield && !shield.Behind && !shield.Hidden) {
                    Draw.SetBlendMode(shield.BlendMode);
                    Draw.SetTextureBlend(true);
                    Draw.SetBlendColor(1.0, 1.0, 1.0, shield.Alpha);
                    Draw.Sprite(shield.Sprite, shield.CurrentAnimation, shield.CurrentFrame, 0.0, 0.0, shield.Flip, false);
                    Draw.SetTextureBlend(false);
                    Draw.SetBlendMode(BlendMode_NORMAL);
                }
            Draw.Restore();
        }
    }

    event GetAngleMode(v) {
        var angleMode;
        if ((v + 0x20) & 0x80) {
            angleMode = v;
            if (angleMode & 0x80) { // if negative
                angleMode--;
            }
            angleMode += 0x20;
        }
        else {
            angleMode = v;
            if (angleMode & 0x80) { // if negative
                angleMode++;
            }
            angleMode += 0x1F;
        }
        angleMode &= 0xC0;
        return angleMode;
    }
    event RadiansToHex(rad) {
        return rad * 128.0 / Math_PI;
    }
    event HexToRadians(rad) {
        return rad * Math_PI / 128.0;
    }
}
